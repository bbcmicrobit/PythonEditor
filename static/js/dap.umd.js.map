{"version":3,"file":"dap.umd.js","sources":["../node_modules/rollup-plugin-node-builtins/src/es6/events.js","../src/processor/enums.ts","../src/proxy/cmsis-dap.ts","../src/daplink/index.ts","../src/dap/adi.ts","../src/processor/cortex-m.ts","../src/transport/hid.ts","../node_modules/rollup-plugin-node-builtins/src/es6/os.js","../src/transport/usb.ts","../src/transport/webusb.ts"],"sourcesContent":["'use strict';\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nexport default EventEmitter;\nexport {EventEmitter};\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n/**\n * Processor Core States\n */\nexport const enum CoreState {\n    /**\n     * The core has been reset\n     */\n    RESET,\n    /**\n     * Core is running with a lockup condition\n     */\n    LOCKUP,\n    /**\n     * The core is sleeping\n     */\n    SLEEPING,\n    /**\n     * The core is in debug state\n     */\n    DEBUG,\n    /**\n     * The core is running\n     */\n    RUNNING\n}\n\n/**\n * Processor Core Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100230_0004_00_en/way1435345987733.html\n */\nexport const enum CoreRegister {\n    /**\n     * General purpose register\n     */\n    R0 = 0,\n    /**\n     * General purpose register\n     */\n    R1 = 1,\n    /**\n     * General purpose register\n     */\n    R2 = 2,\n    /**\n     * General purpose register\n     */\n    R3 = 3,\n    /**\n     * General purpose register\n     */\n    R4 = 4,\n    /**\n     * General purpose register\n     */\n    R5 = 5,\n    /**\n     * General purpose register\n     */\n    R6 = 6,\n    /**\n     * General purpose register\n     */\n    R7 = 7,\n    /**\n     * General purpose register\n     */\n    R8 = 8,\n    /**\n     * General purpose register\n     */\n    R9 = 9,\n    /**\n     * General purpose register\n     */\n    R10 = 10,\n    /**\n     * General purpose register\n     */\n    R11 = 11,\n    /**\n     * General purpose register\n     */\n    R12 = 12,\n    /**\n     * Stack Pointer\n     */\n    SP = 13,\n    /**\n     * The Link Register\n     */\n    LR = 14,\n    /**\n     * The Program Counter\n     */\n    PC = 15,\n    /**\n     * The Program Status Register\n     */\n    PSR = 16,\n    /**\n     * Main Stack Pointer\n     */\n    MSP = 17,\n    /**\n     * Process Stack Pointer\n     */\n    PSP = 18,\n    /**\n     * Prevents activation of exceptions\n     */\n    PRIMASK = 20,\n    /**\n     * Controls the stack used\n     */\n    CONTROL = 20\n}\n\n/**\n * Debug Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100165_0201_00_en/ric1417175947147.html\n */\nexport const enum DebugRegister {\n    /**\n     * Debug Fault Status Register\n     */\n    DFSR = 0xE000ED30,\n    /**\n     * Debug Halting Control and Status Register\n     */\n    DHCSR = 0xE000EDF0,\n    /**\n     * Debug Core Register Selector Register, write only\n     */\n    DCRSR = 0xE000EDF4,\n    /**\n     * Debug Core Register Data Register\n     */\n    DCRDR = 0xE000EDF8,\n    /**\n     * Debug Exception and Monitor Control Register\n     */\n    DEMCR = 0xE000EDFC\n}\n\n/**\n * Debug Halting Control and Status Register\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337e/CEGCJAHJ.html\n * @hidden\n */\nexport const enum DhcsrMask {\n    /**\n     * Enables debug\n     */\n    C_DEBUGEN = (1 << 0),\n    /**\n     * Halts the core\n     */\n    C_HALT = (1 << 1),\n    /**\n     * Steps the core in halted debug\n     */\n    C_STEP = (1 << 2),\n    /**\n     * Mask interrupts when stepping or running in halted debug\n     */\n    C_MASKINTS = (1 << 3),\n    /**\n     * Enables Halting debug to gain control\n     */\n    C_SNAPSTALL = (1 << 5),\n    /**\n     * Register Read/Write on the Debug Core Register Selector register is available\n     */\n    S_REGRDY = (1 << 16),\n    /**\n     * The core is in debug state\n     */\n    S_HALT = (1 << 17),\n    /**\n     * Indicates that the core is sleeping\n     */\n    S_SLEEP = (1 << 18),\n    /**\n     * Core is running (not halted) and a lockup condition is present\n     */\n    S_LOCKUP = (1 << 19),\n    /**\n     * An instruction has completed since last read\n     */\n    S_RETIRE_ST = (1 << 24),\n    /**\n     * The core has been reset\n     */\n    S_RESET_ST = (1 << 25),\n    /**\n     * Debug Key\n     */\n    DBGKEY = (0xA05F << 16)\n}\n\n/**\n * Debug Fault Status Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0413d/Cihdifbf.html\n * @hidden\n */\nexport const enum DfsrMask {\n    /**\n     * Halt request flag\n     */\n    HALTED = (1 << 0),\n    /**\n     * BKPT instruction or hardware breakpoint match\n     */\n    BKPT = (1 << 1),\n    /**\n     * Data Watchpoint (DW) flag\n     */\n    DWTTRAP = (1 << 2),\n    /**\n     * Vector catch occurred\n     */\n    VCATCH = (1 << 3),\n    /**\n     * External debug request (EDBGRQ) has halted the core\n     */\n    EXTERNAL = (1 << 4)\n}\n\n/**\n * Debug Core Register Selector Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/CEGIAJBH.html\n * @hidden\n */\nexport const enum DcrsrMask {\n    /**\n     * Register write or read, write is 1\n     */\n    REGWnR = (1 << 16),\n    /**\n     * Register select - DebugReturnAddress & PSR/Flags, Execution Number, and state information\n     */\n    REGSEL = 0x1F,\n}\n\n/**\n * Flash Patch and Breakpoint Registers\n * http://infocenter.arm.com/help/topic/com.arm.doc.100165_0201_00_en/ric1417175949176.html\n * @hidden\n */\nexport const enum FPBRegister {\n    /**\n     * FlashPatch Control Register\n     */\n    FP_CTRL = 0xE0002000,\n    /**\n     * FlashPatch Remap Register\n     */\n    FP_REMAP = 0xE0002004,\n    /**\n     * FlashPatch Comparator Register0\n     */\n    FP_COMP0 = 0xE0002008,\n    /**\n     * FlashPatch Comparator Register1\n     */\n    FP_COMP1 = 0xE000200C,\n    /**\n     * FlashPatch Comparator Register2\n     */\n    FP_COMP2 = 0xE0002010,\n    /**\n     * FlashPatch Comparator Register3\n     */\n    FP_COMP3 = 0xE0002014,\n    /**\n     * FlashPatch Comparator Register4\n     */\n    FP_COMP4 = 0xE0002018,\n    /**\n     * FlashPatch Comparator Register5\n     */\n    FP_COMP5 = 0xE000201C,\n    /**\n     * FlashPatch Comparator Register6\n     */\n    FP_COMP6 = 0xE0002020,\n    /**\n     * FlashPatch Comparator Register7\n     */\n    FP_COMP7 = 0xE0002024,\n}\n\n/**\n * Flash Patch and Breakpoint Control Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/ch11s04s01.html#BABCAFAG\n * @hidden\n */\nexport enum FPBCtrlMask {\n    /**\n     * Flash patch unit enable\n     */\n    ENABLE = (1 << 0),\n    /**\n     * Key field which enables writing to the Flash Patch Control Register\n     */\n    KEY = (1 << 1)\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventEmitter } from \"events\";\nimport { Transport } from \"../transport\";\nimport {\n    DAPPort,\n    DAPTransferMode,\n    DAPProtocol,\n    DAPCommand,\n    DAPConnectResponse,\n    DAPResponse,\n    DAPInfoRequest,\n    DAPResetTargeResponse,\n    DAPTransferResponse\n} from \"./enums\";\nimport { Proxy, DAPOperation } from \"./\";\n\n/**\n * @hidden\n */\nexport const DEFAULT_CLOCK_FREQUENCY = 10000000;\n/**\n * @hidden\n */\nconst SWD_SEQUENCE = 0xE79E;\n/**\n * @hidden\n */\nconst JTAG_SEQUENCE = 0xE73C;\n\n/**\n * @hidden\n */\nconst BLOCK_HEADER_SIZE = 4;\n/**\n * @hidden\n */\nconst TRANSFER_HEADER_SIZE = 2;\n/**\n * @hidden\n */\nconst TRANSFER_OPERATION_SIZE = 5;\n\n/**\n * CMSIS-DAP class\n * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__Commands__gr.html\n */\nexport class CmsisDAP extends EventEmitter implements Proxy {\n\n    /**\n     * The maximum DAPOperations which can be transferred\n     */\n    public operationCount: number;\n\n    /**\n     * The maximum block size which can be transferred\n     */\n    public blockSize: number;\n\n    /**\n     * CMSIS-DAP constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(private transport: Transport, private mode: DAPProtocol = DAPProtocol.DEFAULT, private clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super();\n\n        // Determine the block size\n        this.blockSize = this.transport.packetSize - BLOCK_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER_BLOCK command\n\n        // Determine the operation count possible\n        const operationSpace = this.transport.packetSize - TRANSFER_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER command\n        this.operationCount = Math.floor(operationSpace / TRANSFER_OPERATION_SIZE);\n    }\n\n    private delay(timeout: number): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            setTimeout(resolve, timeout);\n        });\n    }\n\n    private bufferSourceToUint8Array(prefix: number, data?: BufferSource): Uint8Array {\n\n        if (!data) {\n            return new Uint8Array([prefix]);\n        }\n\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const result = new Uint8Array(arrayBuffer.byteLength + 1);\n\n        result.set([prefix]);\n        result.set(new Uint8Array(arrayBuffer), 1);\n\n        return result;\n    }\n\n    /**\n     * Switches the CMSIS-DAP unit to use SWD\n     * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0316d/Chdhfbhc.html\n     */\n    protected selectProtocol(protocol: DAPProtocol): Promise<void> {\n        const sequence = protocol === DAPProtocol.JTAG ? JTAG_SEQUENCE : SWD_SEQUENCE;\n\n        return this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])) // Sequence of 1's\n        .then(() => this.swjSequence(new Uint16Array([sequence]))) // Send protocol sequence\n        .then(() => this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]))) // Sequence of 1's\n        .then(() => this.swjSequence(new Uint8Array([0x00])));\n    }\n\n    /**\n     * Send a command\n     * @param command Command to send\n     * @param data Data to use\n     * @returns Promise of DataView\n     */\n    protected send(command: number, data?: BufferSource): Promise<DataView> {\n        const array = this.bufferSourceToUint8Array(command, data);\n\n        return this.transport.write(array)\n        .then(() => this.transport.read())\n        .then(response => {\n            if (response.getUint8(0) !== command) {\n                throw new Error(`Bad response for ${command} -> ${response.getUint8(0)}`);\n            }\n\n            switch (command) {\n                case DAPCommand.DAP_DISCONNECT:\n                case DAPCommand.DAP_WRITE_ABORT:\n                case DAPCommand.DAP_DELAY:\n                case DAPCommand.DAP_RESET_TARGET:\n                case DAPCommand.DAP_SWJ_CLOCK:\n                case DAPCommand.DAP_SWJ_SEQUENCE:\n                case DAPCommand.DAP_SWD_CONFIGURE:\n                case DAPCommand.DAP_SWD_SEQUENCE:\n                case DAPCommand.DAP_SWO_TRANSPORT:\n                case DAPCommand.DAP_SWO_MODE:\n                case DAPCommand.DAP_SWO_CONTROL:\n                case DAPCommand.DAP_JTAG_CONFIGURE:\n                case DAPCommand.DAP_JTAG_ID_CODE:\n                case DAPCommand.DAP_TRANSFER_CONFIGURE:\n                    if (response.getUint8(1) !== DAPResponse.DAP_OK) {\n                        throw new Error(`Bad status for ${command} -> ${response.getUint8(1)}`);\n                    }\n            }\n\n            return response;\n        });\n    }\n\n    /**\n     * Get DAP information\n     * @param request Type of information to get\n     * @returns Promise of number or string\n     */\n    public dapInfo(request: DAPInfoRequest): Promise<number | string> {\n        return this.send(DAPCommand.DAP_INFO, new Uint8Array([request]))\n        .then(result => {\n            const length = result.getUint8(1);\n\n            if (length === 0) {\n                throw new Error(\"DAP Info Failure\");\n            }\n\n            switch (request) {\n                case DAPInfoRequest.CAPABILITIES:\n                case DAPInfoRequest.PACKET_COUNT:\n                case DAPInfoRequest.PACKET_SIZE:\n                case DAPInfoRequest.SWO_TRACE_BUFFER_SIZE:\n                    // Byte\n                    if (length === 1) return result.getUint8(2);\n\n                    // Short\n                    if (length === 2) return result.getUint16(2);\n\n                    // Word\n                    if (length === 4) return result.getUint32(2);\n            }\n\n            const ascii = Array.prototype.slice.call(new Uint8Array(result.buffer, 2, length));\n            return String.fromCharCode.apply(null, ascii);\n        });\n    }\n\n    /**\n     * Send an SWJ Sequence\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Sequence.html\n     * @param sequence The sequence to send\n     * @returns Promise\n     */\n    public swjSequence(sequence: BufferSource): Promise<void> {\n        const bitLength = sequence.byteLength * 8;\n        const data = this.bufferSourceToUint8Array(bitLength, sequence);\n\n        return this.send(DAPCommand.DAP_SWJ_SEQUENCE, data)\n        .then(() => undefined);\n    }\n\n    /**\n     * Configure Transfer\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__TransferConfigure.html\n     * @param idleCycles Number of extra idle cycles after each transfer\n     * @param waitRetry Number of transfer retries after WAIT response\n     * @param matchRetry Number of retries on reads with Value Match in DAP_Transfer\n     * @returns Promise\n     */\n    public configureTransfer(idleCycles: number, waitRetry: number, matchRetry: number): Promise<void> {\n        const data = new Uint8Array(5);\n        const view = new DataView(data.buffer);\n\n        view.setUint8(0, idleCycles);\n        view.setUint16(1, waitRetry, true);\n        view.setUint16(3, matchRetry, true);\n\n        return this.send(DAPCommand.DAP_TRANSFER_CONFIGURE, data)\n        .then(() => undefined);\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public connect(): Promise<void> {\n        return this.transport.open()\n        .then(() => this.send(DAPCommand.DAP_SWJ_CLOCK, new Uint32Array([this.clockFrequency])))\n        .then(() => this.send(DAPCommand.DAP_CONNECT, new Uint8Array([this.mode])))\n        .then(result => {\n            if (result.getUint8(1) === DAPConnectResponse.FAILED || this.mode !== DAPProtocol.DEFAULT && result.getUint8(1) !== this.mode) {\n                throw new Error(\"Mode not enabled.\");\n            }\n        })\n        .then(() => this.configureTransfer(0, 100, 0))\n        .then(() => this.selectProtocol(DAPProtocol.SWD));\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public disconnect(): Promise<void> {\n        return this.send(DAPCommand.DAP_DISCONNECT)\n        .then(() => {\n            return this.transport.close();\n        });\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public reconnect(): Promise<void> {\n        return this.disconnect()\n        .then(() => this.delay(100))\n        .then(() => this.connect());\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise of whether a device specific reset sequence is implemented\n     */\n    public reset(): Promise<boolean> {\n        return this.send(DAPCommand.DAP_RESET_TARGET)\n        .then(response => response.getUint8(2) === DAPResetTargeResponse.RESET_SEQUENCE);\n    }\n\n    /**\n     * Transfer data with a single read or write operation\n     * @param port Port type (debug port or access port)\n     * @param mode Whether to read or write\n     * @param register The register to use\n     * @param value Any value to write\n     * @returns Promise of any value read\n     */\n    public transfer(port: DAPPort, mode: DAPTransferMode, register: number, value?: number): Promise<number>;\n    /**\n     * Transfer data with multiple read or write operations\n     * @param operations The operations to use\n     * @returns Promise of any values read\n     */\n    public transfer(operations: DAPOperation[]): Promise<Uint32Array>;\n    public transfer(portOrOps: DAPPort | DAPOperation[], mode: DAPTransferMode = DAPTransferMode.READ, register: number = 0, value: number = 0): Promise<number | Uint32Array> {\n\n        let operations: DAPOperation[];\n\n        if (typeof portOrOps === \"number\") {\n            operations = [{\n                port: portOrOps,\n                mode,\n                register,\n                value\n            }];\n        } else {\n            operations = portOrOps;\n        }\n\n        const data = new Uint8Array(TRANSFER_HEADER_SIZE + (operations.length * TRANSFER_OPERATION_SIZE));\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint8(1, operations.length);\n\n        operations.forEach((operation, index) => {\n            const offset = TRANSFER_HEADER_SIZE + (index * TRANSFER_OPERATION_SIZE);\n\n            // Transfer request\n            view.setUint8(offset, operation.port | operation.mode | operation.register);\n            // Transfer data\n            view.setUint32(offset + 1, operation.value || 0, true);\n        });\n\n        return this.send(DAPCommand.DAP_TRANSFER, data)\n        .then(result => {\n\n            // Transfer count\n            if (result.getUint8(1) !== operations.length) {\n                throw new Error(\"Transfer count mismatch\");\n            }\n\n            // Transfer response\n            const response = result.getUint8(2);\n            if (response === DAPTransferResponse.WAIT) {\n                throw new Error(\"Transfer response WAIT\");\n            }\n            if (response === DAPTransferResponse.FAULT) {\n                throw new Error(\"Transfer response FAULT\");\n            }\n            if (response === DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error(\"Transfer response PROTOCOL_ERROR\");\n            }\n            if (response === DAPTransferResponse.VALUE_MISMATCH) {\n                throw new Error(\"Transfer response VALUE_MISMATCH\");\n            }\n            if (response === DAPTransferResponse.NO_ACK) {\n                throw new Error(\"Transfer response NO_ACK\");\n            }\n\n            if (typeof portOrOps === \"number\") {\n                return result.getUint32(3, true);\n            }\n\n            const length = operations.length * 4;\n            return new Uint32Array(result.buffer.slice(3, 3 + length));\n        });\n    }\n\n    /**\n     * Read a block of data from a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @returns Promise of values read\n     */\n    public transferBlock(port: DAPPort, register: number, count: number): Promise<Uint32Array>;\n    /**\n     * Write a block of data to a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @param values The values to write\n     * @returns Promise\n     */\n    public transferBlock(port: DAPPort, register: number, values: Uint32Array): Promise<undefined>;\n    public transferBlock(port: DAPPort, register: number, countOrValues: number | Uint32Array): Promise<Uint32Array | undefined> {\n\n        let operationCount: number;\n        let mode: DAPTransferMode;\n        let dataSize = BLOCK_HEADER_SIZE;\n\n        if (typeof countOrValues === \"number\") {\n            operationCount = countOrValues;\n            mode = DAPTransferMode.READ;\n        } else {\n            operationCount = countOrValues.length;\n            mode = DAPTransferMode.WRITE;\n            dataSize += countOrValues.byteLength;\n        }\n\n        const data = new Uint8Array(dataSize);\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint16(1, operationCount, true);\n        // Transfer request\n        view.setUint8(3, port | mode | register);\n\n        if (typeof countOrValues !== \"number\") {\n            // Transfer data\n            data.set(countOrValues, BLOCK_HEADER_SIZE);\n        }\n\n        return this.send(DAPCommand.DAP_TRANSFER_BLOCK, view)\n        .then(result => {\n\n            // Transfer count\n            if (result.getUint16(1, true) !== operationCount) {\n                throw new Error(\"Transfer count mismatch\");\n            }\n\n            // Transfer response\n            const response = result.getUint8(3);\n            if (response & DAPTransferResponse.WAIT) {\n                throw new Error(\"Transfer response WAIT\");\n            }\n            if (response & DAPTransferResponse.FAULT) {\n                throw new Error(\"Transfer response FAULT\");\n            }\n            if (response & DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error(\"Transfer response PROTOCOL_ERROR\");\n            }\n            if (response & DAPTransferResponse.NO_ACK) {\n                throw new Error(\"Transfer response NO_ACK\");\n            }\n\n            if (typeof countOrValues === \"number\") {\n                return new Uint32Array(result.buffer.slice(4));\n            }\n\n            return undefined;\n        });\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { CmsisDAP, Proxy } from \"../proxy\";\nimport { DAPLinkFlash, DAPLinkSerial } from \"./enums\";\n\n/**\n * @hidden\n */\nconst DEFAULT_BAUDRATE = 9600;\n/**\n * @hidden\n */\nconst DEFAULT_SERIAL_DELAY = 200;\n/**\n * @hidden\n */\nconst DEFAULT_PAGE_SIZE = 62;\n\n/**\n * DAPLink Class\n */\nexport class DAPLink extends CmsisDAP implements Proxy {\n\n    /**\n     * Progress event\n     * @event\n     */\n    public static EVENT_PROGRESS: string = \"progress\";\n\n    /**\n     * Serial read event\n     * @event\n     */\n    public static EVENT_SERIAL_DATA: string = \"serial\";\n\n    private timer?: any;\n\n    /**\n     * Detect if buffer contains text or binary data\n     */\n    private isBufferBinary(buffer: ArrayBuffer): boolean {\n        const numberArray = Array.prototype.slice.call(new Uint16Array(buffer, 0, 50));\n        const bufferString: string = String.fromCharCode.apply(null, numberArray);\n\n        for (let i = 0; i < bufferString.length; i++) {\n            const charCode = bufferString.charCodeAt(i);\n            // 65533 is a code for unknown character\n            // 0-8 are codes for control characters\n            if (charCode === 65533 || charCode <= 8) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private writeBuffer(buffer: ArrayBuffer, pageSize: number, offset: number = 0): Promise<void> {\n        const end = Math.min(buffer.byteLength, offset + pageSize);\n        const page = buffer.slice(offset, end);\n        const data = new Uint8Array(page.byteLength + 1);\n\n        data.set([page.byteLength]);\n        data.set(new Uint8Array(page), 1);\n\n        return this.send(DAPLinkFlash.WRITE, data)\n        .then(() => {\n            this.emit(DAPLink.EVENT_PROGRESS, offset / buffer.byteLength);\n            if (end < buffer.byteLength) {\n                return this.writeBuffer(buffer, pageSize, end);\n            }\n            return Promise.resolve();\n        });\n    }\n\n    /**\n     * Flash the target\n     * @param buffer The image to flash\n     * @param pageSize The page size to use (defaults to 62)\n     * @returns Promise\n     */\n    public flash(buffer: BufferSource, pageSize: number = DEFAULT_PAGE_SIZE): Promise<void> {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(buffer) ? buffer.buffer : buffer;\n        const streamType = this.isBufferBinary(arrayBuffer) ? 0 : 1;\n\n        return this.send(DAPLinkFlash.OPEN, new Uint32Array([streamType]))\n        .then(result => {\n            // An error occurred\n            if (result.getUint8(1) !== 0) return Promise.reject(\"Flash error\");\n            return this.writeBuffer(arrayBuffer, pageSize);\n        })\n        .then(() => {\n            this.emit(DAPLink.EVENT_PROGRESS, 1.0);\n            return this.send(DAPLinkFlash.CLOSE);\n        })\n        .then(result => {\n            // An error occurred\n            if (result.getUint8(1) !== 0) return Promise.reject(\"Flash error\");\n            return this.send(DAPLinkFlash.RESET);\n        })\n        .then(() => undefined);\n    }\n\n    /**\n     * Get the serial baud rate setting\n     * @returns Promise of baud rate\n     */\n    public getSerialBaudrate(): Promise<number> {\n        return this.send(DAPLinkSerial.READ_SETTINGS)\n        .then(result => {\n            return result.getUint32(1, true);\n        });\n    }\n\n    /**\n     * Set the serial baud rate setting\n     * @param baudrate The baudrate to use (defaults to 9600)\n     * @returns Promise\n     */\n    public setSerialBaudrate(baudrate: number = DEFAULT_BAUDRATE): Promise<void> {\n        return this.send(DAPLinkSerial.WRITE_SETTINGS, new Uint32Array([baudrate]))\n        .then(() => undefined);\n    }\n\n    /**\n     * Start listening for serial data\n     * @param serialDelay The serial delay to use (defaults to 200)\n     */\n    public startSerialRead(serialDelay: number = DEFAULT_SERIAL_DELAY) {\n        this.stopSerialRead();\n        this.timer = setInterval(() => {\n            return this.send(DAPLinkSerial.READ)\n            .then(serialData => {\n                if (serialData.byteLength > 0) {\n                    // check if there is any data returned from the device\n                    // first byte contains the vendor code\n                    // second byte contains the actual length of data read from the device\n                    const dataLength = serialData.getUint8(1);\n                    if (dataLength !== 0) {\n                        const offset = 2;\n                        const dataArray = serialData.buffer.slice(offset, offset + dataLength);\n                        const numberArray = Array.prototype.slice.call(new Uint8Array(dataArray));\n                        const data = String.fromCharCode.apply(null, numberArray);\n                        this.emit(DAPLink.EVENT_SERIAL_DATA, data);\n                    }\n                }\n            });\n        }, serialDelay);\n    }\n\n    /**\n     * Stop listening for serial data\n     */\n    public stopSerialRead() {\n        if (this.timer) {\n            clearInterval(this.timer);\n            this.timer = undefined;\n        }\n    }\n\n    /**\n     * Write serial data\n     * @param data The data to write\n     * @returns Promise\n     */\n    public serialWrite(data: string): Promise<void> {\n        const arrayData = data.split(\"\").map((e: string) => e.charCodeAt(0));\n        arrayData.unshift(arrayData.length);\n        return this.send(DAPLinkSerial.WRITE, new Uint8Array(arrayData).buffer)\n        .then(() => undefined);\n    }\n}\n\nexport * from \"./enums\";\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from \"../transport\";\nimport { Proxy, CmsisDAP, DAPOperation } from \"../proxy\";\nimport { DPRegister, APRegister, CSWMask, BankSelectMask, AbortMask, CtrlStatMask } from \"./enums\";\nimport { DAP } from \"./\";\nimport { DAPTransferMode, DAPPort, DAPProtocol } from \"../proxy/enums\";\nimport { DEFAULT_CLOCK_FREQUENCY } from \"../proxy/cmsis-dap\";\n\n/**\n * Arm Debug Interface class\n */\nexport class ADI implements DAP {\n\n    private selectedAddress?: number;\n    private cswValue?: number;\n    private proxy: Proxy;\n\n    /**\n     * ADI constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use (default 0)\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode?: DAPProtocol, clockFrequency?: number);\n    /**\n     * ADI constructor\n     * @param proxy Proxy to use\n     */\n    constructor(proxy: Proxy);\n    constructor(transportOrDap: Transport | Proxy, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        function isTransport(test: Transport | Proxy): test is Transport {\n            return (test as Transport).open !== undefined;\n        }\n        this.proxy = isTransport(transportOrDap) ? new CmsisDAP(transportOrDap, mode, clockFrequency) : transportOrDap;\n    }\n\n    protected delay(timeout: number): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            setTimeout(resolve, timeout);\n        });\n    }\n\n    /**\n     * Continually run a function until it returns true\n     * @param fn The function to run\n     * @param timer The milliseconds to wait between each run\n     * @param timeout Optional timeout to wait before giving up and rejecting\n     * @returns Promise\n     */\n    protected waitDelay(fn: () => Promise<boolean>, timer: number = 100, timeout: number = 0): Promise<void> {\n        let running: boolean = true;\n\n        const chain = (condition: boolean): Promise<void> => {\n            if (!running) return Promise.resolve();\n            return condition\n                ? Promise.resolve()\n                : this.delay(timer)\n                .then(fn)\n                .then(chain);\n        };\n\n        return new Promise((resolve, reject) => {\n            if (timeout > 0) {\n                setTimeout(() => {\n                    running = false;\n                    reject(\"Wait timed out\");\n                }, timeout);\n            }\n\n            return chain(false)\n            .then(() => resolve());\n        });\n    }\n\n    protected concatTypedArray(arrays: Uint32Array[]): Uint32Array {\n        // Only one array exists\n        if (arrays.length === 1) return arrays[0];\n\n        // Determine array length\n        let length: number = 0;\n        for (const array of arrays) {\n            length += array.length;\n        }\n\n        // Concat the arrays\n        const result = new Uint32Array(length);\n        for (let i = 0, j = 0; i < arrays.length; i++) {\n            result.set(arrays[i], j);\n            j += arrays[i].length;\n        }\n\n        return result;\n    }\n\n    protected readDPCommand(register: number): DAPOperation[] {\n        return [{\n            mode: DAPTransferMode.READ,\n            port: DAPPort.DEBUG,\n            register\n        }];\n    }\n\n    protected writeDPCommand(register: number, value: number): DAPOperation[] {\n        if (register === DPRegister.SELECT) {\n            if (value === this.selectedAddress) {\n                return [];\n            }\n            this.selectedAddress = value;\n        }\n\n        return [{\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.DEBUG,\n            register,\n            value\n        }];\n    }\n\n    protected readAPCommand(register: number): DAPOperation[] {\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.READ,\n            port: DAPPort.ACCESS,\n            register\n        });\n    }\n\n    protected writeAPCommand(register: number, value: number): DAPOperation[] {\n        if (register === APRegister.CSW) {\n            if (value === this.cswValue) {\n                return [];\n            }\n            this.cswValue = value;\n        }\n\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.ACCESS,\n            register,\n            value\n        });\n    }\n\n    protected readMem16Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem16Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.writeAPCommand(APRegister.DRW, value));\n    }\n\n    protected readMem32Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem32Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.writeAPCommand(APRegister.DRW, value as number));\n    }\n\n    protected transferSequence(operations: DAPOperation[][]): Promise<Uint32Array> {\n        // Flatten operations into single array\n        let merged: DAPOperation[] = [];\n        merged = merged.concat(...operations);\n\n        let chain: Promise<Uint32Array[]> = Promise.resolve([]);\n\n        // Split operations into sequences no longer than operation count\n        while (merged.length) {\n            const sequence = merged.splice(0, this.proxy.operationCount);\n            chain = chain.then(results => this.proxy.transfer(sequence).then(result => [...results, result]));\n        }\n\n        return chain\n        .then(arrays => this.concatTypedArray(arrays));\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public connect() {\n        const mask = CtrlStatMask.CDBGPWRUPACK | CtrlStatMask.CSYSPWRUPACK;\n\n        return this.proxy.connect()\n        .then(() => this.readDP(DPRegister.DPIDR))\n        .then(() => this.transferSequence([\n            this.writeDPCommand(DPRegister.ABORT, AbortMask.STKERRCLR), // clear sticky error\n            this.writeDPCommand(DPRegister.SELECT, APRegister.CSW), // select CTRL_STAT\n            this.writeDPCommand(DPRegister.CTRL_STAT, CtrlStatMask.CSYSPWRUPREQ | CtrlStatMask.CDBGPWRUPREQ)\n        ]))\n        // Wait until system and debug have powered up\n        .then(() => this.waitDelay(() => {\n            return this.readDP(DPRegister.CTRL_STAT)\n            .then(status => ((status & mask) === mask));\n        }));\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public disconnect(): Promise<void> {\n        return this.proxy.disconnect();\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public reconnect(): Promise<void> {\n        return this.disconnect()\n        .then(() => this.delay(100))\n        .then(() => this.connect());\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise\n     */\n    public reset(): Promise<boolean> {\n        return this.proxy.reset();\n    }\n\n    /**\n     * Read from a debug port register\n     * @param register DP register to read\n     * @returns Promise of register value\n     */\n    public readDP(register: DPRegister): Promise<number> {\n        return this.proxy.transfer(this.readDPCommand(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write to a debug port register\n     * @param register DP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public writeDP(register: DPRegister, value: number): Promise<void> {\n        return this.proxy.transfer(this.writeDPCommand(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read from an access port register\n     * @param register AP register to read\n     * @returns Promise of register value\n     */\n    public readAP(register: APRegister): Promise<number> {\n        return this.proxy.transfer(this.readAPCommand(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write to an access port register\n     * @param register AP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public writeAP(register: APRegister, value: number): Promise<void> {\n        return this.proxy.transfer(this.writeAPCommand(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read a 16-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public readMem16(register: number): Promise<number> {\n        return this.proxy.transfer(this.readMem16Command(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write a 16-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public writeMem16(register: number, value: number): Promise<void> {\n        value = value as number << ((register & 0x02) << 3);\n        return this.proxy.transfer(this.writeMem16Command(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read a 32-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public readMem32(register: number): Promise<number> {\n        return this.proxy.transfer(this.readMem32Command(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write a 32-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public writeMem32(register: number, value: number): Promise<void> {\n        return this.proxy.transfer(this.writeMem32Command(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read a block of 32-bit words from a memory access port register\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public readBlock(register: number, count: number): Promise<Uint32Array> {\n        let chain: Promise<Uint32Array[]> = this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register),\n        ])\n        .then(() => []);\n\n        // Split into requests no longer than block size\n        let remainder = count;\n        while (remainder > 0) {\n            const chunkSize = Math.min(remainder, this.proxy.blockSize);\n            chain = chain.then(results => this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunkSize)\n            .then(result => [...results, result]));\n            remainder -= chunkSize;\n        }\n\n        return chain\n        .then(arrays => this.concatTypedArray(arrays));\n    }\n\n    /**\n     * Write a block of 32-bit words to a memory access port register\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public writeBlock(register: number, values: Uint32Array): Promise<void> {\n        let chain: Promise<void> = this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register),\n        ])\n        .then(() => undefined);\n\n        // Split values into chunks no longer than block size\n        let index = 0;\n        while (index < values.length) {\n            const chunk = values.slice(index, index + this.proxy.blockSize);\n            chain = chain.then(() => this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunk));\n            index += this.proxy.blockSize;\n        }\n\n        return chain;\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { ADI } from \"../dap\";\nimport {\n    DebugRegister,\n    CoreRegister,\n    DhcsrMask,\n    DfsrMask,\n    DcrsrMask,\n    CoreState\n} from \"./enums\";\nimport { Processor } from \"./\";\nimport { DAPOperation } from \"../proxy\";\n\n/**\n * @hidden\n */\nconst EXECUTE_TIMEOUT = 10000;\n/**\n * @hidden\n */\nconst BKPT_INSTRUCTION = 0xBE2A;\n/**\n * @hidden\n */\nconst GENERAL_REGISTER_COUNT = 12;\n\n/**\n * Cortex M class\n */\nexport class CortexM extends ADI implements Processor {\n\n    private enableDebug() {\n        return this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN);\n    }\n\n    protected readCoreRegisterCommand(register: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRSR, register)\n        .concat(this.readMem32Command(DebugRegister.DHCSR))\n        .concat(this.readMem32Command(DebugRegister.DCRDR));\n    }\n\n    protected writeCoreRegisterCommand(register: number, value: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRDR, value)\n        .concat(this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR));\n    }\n\n    /**\n     * Get the state of the processor core\n     * @returns Promise of CoreState\n     */\n    public getState(): Promise<CoreState> {\n        return this.readMem32(DebugRegister.DHCSR)\n        .then(dhcsr => {\n            let state: CoreState;\n\n            if (dhcsr & DhcsrMask.S_LOCKUP) state = CoreState.LOCKUP;\n            else if (dhcsr & DhcsrMask.S_SLEEP) state = CoreState.SLEEPING;\n            else if (dhcsr & DhcsrMask.S_HALT) state = CoreState.DEBUG;\n            else state = CoreState.RUNNING;\n\n            if (dhcsr & DhcsrMask.S_RESET_ST) {\n                // The core has been reset, check if an instruction has run\n                return this.readMem32(DebugRegister.DHCSR)\n                .then(newDhcsr => {\n                    if (newDhcsr & DhcsrMask.S_RESET_ST && !(newDhcsr & DhcsrMask.S_RETIRE_ST)) {\n                        return CoreState.RESET;\n                    } else {\n                        return state;\n                    }\n                });\n            } else {\n                return state;\n            }\n        });\n    }\n\n    /**\n     * Whether the target is halted\n     * @returns Promise of halted state\n     */\n    public isHalted(): Promise<boolean> {\n        return this.readMem32(DebugRegister.DHCSR)\n        .then(dhcsr => {\n            return !!(dhcsr & DhcsrMask.S_HALT);\n        });\n    }\n\n    /**\n     * Halt the target\n     * @param wait Wait until halted before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public halt(wait: boolean = true, timeout: number = 0): Promise<void> {\n        return this.isHalted()\n        .then(halted => {\n            if (halted) return Promise.resolve();\n\n            return this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN | DhcsrMask.C_HALT)\n            .then(() => {\n                if (!wait) return Promise.resolve();\n\n                return this.waitDelay(() => this.isHalted(), 100, timeout);\n            });\n        });\n    }\n\n    /**\n     * Resume a target\n     * @param wait Wait until resumed before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public resume(wait: boolean = true, timeout: number = 0) {\n        return this.isHalted()\n        .then(halted => {\n            if (!halted) return Promise.resolve();\n\n            return this.writeMem32(DebugRegister.DFSR, DfsrMask.DWTTRAP | DfsrMask.BKPT | DfsrMask.HALTED)\n            .then(() => this.enableDebug())\n            .then(() => {\n                if (!wait) return Promise.resolve();\n\n                return this.waitDelay(() => this.isHalted().then(result => !result), 100, timeout);\n            });\n        });\n    }\n\n    /**\n     * Read from a core register\n     * @param register The register to read\n     * @returns Promise of value\n     */\n    public readCoreRegister(register: CoreRegister): Promise<number> {\n        return this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRSR, register),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ])\n        .then(results => {\n            const dhcsr = results[0];\n            if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n                throw new Error(\"Register not ready\");\n            }\n\n            return this.readMem32(DebugRegister.DCRDR);\n        });\n    }\n\n    /**\n     * Read an array of core registers\n     * @param registers The registers to read\n     * @returns Promise of register values in an array\n     */\n    public readCoreRegisters(registers: CoreRegister[]): Promise<number[]> {\n        let chain: Promise<number[]> = Promise.resolve([]);\n\n        registers.forEach(register => {\n            chain = chain.then(results => this.readCoreRegister(register).then(result => [...results, result]));\n        });\n\n        return chain;\n    }\n\n    /**\n     * Write to a core register\n     * @param register The register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public writeCoreRegister(register: CoreRegister, value: number): Promise<void> {\n        return this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRDR, value),\n            this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ])\n        .then(results => {\n            const dhcsr = results[0];\n            if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n                throw new Error(\"Register not ready\");\n            }\n        });\n    }\n\n    /**\n     * Exucute code at a specified memory address\n     * @param address The address to put the code\n     * @param code The code to use\n     * @param stackPointer The stack pointer to use\n     * @param programCounter The program counter to use\n     * @param linkRegister The link register to use (defaults to address + 1)\n     * @param registers Values to add to the general purpose registers, R0, R1, R2, etc.\n     */\n    public execute(address: number, code: Uint32Array, stackPointer: number, programCounter: number, linkRegister: number = address + 1, ...registers: number[]): Promise<void> {\n\n        // Ensure a breakpoint exists at the end of the code\n        if (code[code.length - 1] !== BKPT_INSTRUCTION) {\n            const newCode = new Uint32Array(code.length + 1);\n            newCode.set(code);\n            newCode.set([BKPT_INSTRUCTION], code.length - 1);\n            code = newCode;\n        }\n\n        // Create sequence of core register writes\n        const sequence = [\n            this.writeCoreRegisterCommand(CoreRegister.SP, stackPointer),\n            this.writeCoreRegisterCommand(CoreRegister.PC, programCounter),\n            this.writeCoreRegisterCommand(CoreRegister.LR, linkRegister)\n        ];\n\n        // Add in register values R0, R1, R2, etc.\n        for (let i = 0; i < Math.min(registers.length, GENERAL_REGISTER_COUNT); i++) {\n            sequence.push(this.writeCoreRegisterCommand(i, registers[i]));\n        }\n\n        return this.halt() // Halt the target\n        .then(() => this.transferSequence(sequence)) // Write the registers\n        .then(() => this.writeBlock(address, code)) // Write the code to the address\n        .then(() => this.resume(false)) // Resume the target, without waiting\n        .then(() => this.waitDelay(() => this.isHalted(), 100, EXECUTE_TIMEOUT)); // Wait for the target to halt on the breakpoint\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { platform } from \"os\";\nimport { HID as nodeHID, Device } from \"node-hid\";\nimport { Transport } from \"./\";\n\n/**\n * HID Transport class\n */\nexport class HID implements Transport {\n\n    private os: string = platform();\n    private path: string;\n    private device?: nodeHID;\n    public readonly packetSize = 64;\n\n    /**\n     * HID constructor\n     * @param path Path to HID device to use\n     */\n    constructor(deviceOrPath: Device | string) {\n        function isDevice(source: Device | string): source is Device {\n            return (source as Device).path !== undefined;\n        }\n\n        this.path = isDevice(deviceOrPath) ? deviceOrPath.path! : deviceOrPath;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public open(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.path.length) {\n                return reject(\"No path specified\");\n            }\n\n            try {\n                const hid = require(\"node-hid\");\n                this.device = new hid.HID(this.path);\n                resolve();\n            } catch (ex) {\n                reject(ex);\n            }\n        });\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public close(): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            if (this.device) {\n                this.device.close();\n            }\n\n            resolve();\n        });\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public read(): Promise<DataView> {\n        return new Promise((resolve, reject) => {\n            if (!this.device) return reject(\"No device opened\");\n\n            this.device.read((error: string, data: number[]) => {\n                if (error) {\n                    return reject(error);\n                }\n\n                const buffer = new Uint8Array(data).buffer;\n                resolve(new DataView(buffer));\n            });\n        });\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public write(data: BufferSource): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.device) return reject(\"No device opened\");\n\n            function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n                return (source as ArrayBufferView).buffer !== undefined;\n            }\n\n            const arrayBuffer = isView(data) ? data.buffer : data;\n            const array = Array.prototype.slice.call(new Uint8Array(arrayBuffer));\n\n            // Pad to packet size\n            while (array.length < this.packetSize) array.push(0);\n\n            // Windows requires the prepend of an extra byte\n            // https://github.com/node-hid/node-hid/blob/master/README.md#prepend-byte-to-hid_write\n            if (this.os === \"win32\") {\n                array.unshift(0);  // prepend throwaway byte\n            }\n\n            const bytesWritten = this.device.write(array);\n            if (bytesWritten !== array.length) return reject(\"Incorrect bytecount written\");\n\n            resolve();\n        });\n    }\n}\n","/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 CoderPuppy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\nvar _endianness;\nexport function endianness() {\n  if (typeof _endianness === 'undefined') {\n    var a = new ArrayBuffer(2);\n    var b = new Uint8Array(a);\n    var c = new Uint16Array(a);\n    b[0] = 1;\n    b[1] = 2;\n    if (c[0] === 258) {\n      _endianness = 'BE';\n    } else if (c[0] === 513){\n      _endianness = 'LE';\n    } else {\n      throw new Error('unable to figure out endianess');\n    }\n  }\n  return _endianness;\n}\n\nexport function hostname() {\n  if (typeof global.location !== 'undefined') {\n    return global.location.hostname\n  } else return '';\n}\n\nexport function loadavg() {\n  return [];\n}\n\nexport function uptime() {\n  return 0;\n}\n\nexport function freemem() {\n  return Number.MAX_VALUE;\n}\n\nexport function totalmem() {\n  return Number.MAX_VALUE;\n}\n\nexport function cpus() {\n  return [];\n}\n\nexport function type() {\n  return 'Browser';\n}\n\nexport function release () {\n  if (typeof global.navigator !== 'undefined') {\n    return global.navigator.appVersion;\n  }\n  return '';\n}\n\nexport function networkInterfaces(){}\nexport function getNetworkInterfaces(){}\n\nexport function arch() {\n  return 'javascript';\n}\n\nexport function platform() {\n  return 'browser';\n}\n\nexport function tmpDir() {\n  return '/tmp';\n}\nexport var tmpdir = tmpDir;\n\nexport var EOL = '\\n';\nexport default {\n  EOL: EOL,\n  tmpdir: tmpdir,\n  tmpDir: tmpDir,\n  networkInterfaces:networkInterfaces,\n  getNetworkInterfaces: getNetworkInterfaces,\n  release: release,\n  type: type,\n  cpus: cpus,\n  totalmem: totalmem,\n  freemem: freemem,\n  uptime: uptime,\n  loadavg: loadavg,\n  hostname: hostname,\n  endianness: endianness,\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Device, InEndpoint, OutEndpoint} from \"usb\";\nimport { Transport } from \"./\";\n\n/**\n * @hidden\n */\nconst LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5);\n/**\n * @hidden\n */\nconst LIBUSB_RECIPIENT_INTERFACE = 0x01;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_OUT = 0x00;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_IN = 0x80;\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * USB Transport class\n */\nexport class USB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: InEndpoint;\n    private endpointOut?: OutEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * USB constructor\n     * @param device USB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: Device, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private bufferToDataView(buffer: Buffer): DataView {\n        const arrayBuffer = new Uint8Array(buffer).buffer;\n        return new DataView(arrayBuffer);\n    }\n\n    private bufferSourceToBuffer(bufferSource: ArrayBuffer | ArrayBufferView): Buffer {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(bufferSource) ? bufferSource.buffer : bufferSource;\n        return Buffer.from(arrayBuffer);\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public open(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.device.open();\n            this.device.setConfiguration(this.configuration, error => {\n                if (error) return reject(error);\n                const interfaces = this.device.interfaces.filter(iface => {\n                    return iface.descriptor.bInterfaceClass === this.interfaceClass;\n                });\n\n                if (!interfaces.length) {\n                    throw new Error(\"No valid interfaces found.\");\n                }\n\n                // Prefer interface with endpoints\n                let selectedInterface = interfaces.find(iface => iface.endpoints.length > 0);\n\n                // Otherwise use the first\n                if (!selectedInterface) {\n                    selectedInterface = interfaces[0];\n                }\n\n                this.interfaceNumber = selectedInterface.interfaceNumber;\n\n                // If we always want to use control transfer, don't find/set endpoints and claim interface\n                if (!this.alwaysControlTransfer) {\n                    const endpoints = selectedInterface.endpoints;\n\n                    this.endpointIn = undefined;\n                    this.endpointOut = undefined;\n\n                    for (const endpoint of endpoints) {\n                        if (endpoint.direction === \"in\") this.endpointIn = (endpoint as InEndpoint);\n                        else this.endpointOut = (endpoint as OutEndpoint);\n                    }\n\n                    // If endpoints are found, claim the interface\n                    if (this.endpointIn || this.endpointOut) {\n\n                        // If the interface can't be claimed, use control transfer\n                        try {\n                            selectedInterface.claim();\n                        } catch (_e) {\n                            this.endpointIn = undefined;\n                            this.endpointOut = undefined;\n                        }\n                    }\n                }\n\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public close(): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            this.device.close();\n            resolve();\n        });\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public read(): Promise<DataView> {\n        return new Promise((resolve, reject) => {\n            if (this.interfaceNumber === undefined) return reject(\"No device opened\");\n\n            // Use endpoint if it exists\n            if (this.endpointIn) {\n                this.endpointIn.transfer(this.packetSize, (error, buffer) => {\n                    if (error) return reject(error);\n                    resolve(this.bufferToDataView(buffer));\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                GET_REPORT,\n                IN_REPORT,\n                this.interfaceNumber,\n                this.packetSize,\n                (error, buffer) => {\n                    if (error) return reject(error);\n                    if (!buffer) return reject(\"No buffer read\");\n                    resolve(this.bufferToDataView(buffer));\n                }\n            );\n        });\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public write(data: BufferSource): Promise<void> {\n        const extended = this.extendBuffer(data, this.packetSize);\n        const buffer = this.bufferSourceToBuffer(extended);\n\n        return new Promise((resolve, reject) => {\n            if (this.interfaceNumber === undefined) return reject(\"No device opened\");\n\n            // Use endpoint if it exists\n            if (this.endpointOut) {\n                this.endpointOut.transfer(buffer, error => {\n                    if (error) return reject(error);\n                    resolve();\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                SET_REPORT,\n                OUT_REPORT,\n                this.interfaceNumber,\n                buffer,\n                error => {\n                    if (error) return reject(error);\n                    resolve();\n                }\n            );\n        });\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from \"./\";\n\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * WebUSB Transport class\n * https://wicg.github.io/webusb/\n */\nexport class WebUSB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: USBEndpoint;\n    private endpointOut?: USBEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * WebUSB constructor\n     * @param device WebUSB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: USBDevice, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public open(): Promise<void> {\n        return this.device.open()\n        .then(() => this.device.selectConfiguration(this.configuration))\n        .then(() => {\n            const interfaces = this.device.configuration!.interfaces.filter(iface => {\n                return iface.alternates[0].interfaceClass === this.interfaceClass;\n            });\n\n            if (!interfaces.length) {\n                throw new Error(\"No valid interfaces found.\");\n            }\n\n            // Prefer interface with endpoints\n            let selectedInterface = interfaces.find(iface => iface.alternates[0].endpoints.length > 0);\n\n            // Otherwise use the first\n            if (!selectedInterface) {\n                selectedInterface = interfaces[0];\n            }\n\n            this.interfaceNumber = selectedInterface.interfaceNumber;\n\n            // If we always want to use control transfer, don't find/set endpoints and claim interface\n            if (!this.alwaysControlTransfer) {\n                const endpoints = selectedInterface.alternates[0].endpoints;\n\n                this.endpointIn = undefined;\n                this.endpointOut = undefined;\n\n                for (const endpoint of endpoints) {\n                    if (endpoint.direction === \"in\") this.endpointIn = endpoint;\n                    else this.endpointOut = endpoint;\n                }\n            }\n\n            return this.device.claimInterface(this.interfaceNumber);\n        });\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public close(): Promise<void> {\n        return this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public read(): Promise<DataView> {\n        if (this.interfaceNumber === undefined) return Promise.reject(\"No device opened\");\n\n        // Use endpoint if it exists\n        if (this.endpointIn) {\n            return this.device.transferIn(\n                this.endpointIn.endpointNumber,\n                this.packetSize\n            )\n            .then(result => result.data!);\n        }\n\n        // Fallback to using control transfer\n        return this.device.controlTransferIn(\n            {\n                requestType: \"class\",\n                recipient: \"interface\",\n                request: GET_REPORT,\n                value: IN_REPORT,\n                index: this.interfaceNumber\n            },\n            this.packetSize\n        )\n        .then(result => result.data!);\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public write(data: BufferSource): Promise<void> {\n        if (this.interfaceNumber === undefined) return Promise.reject(\"No device opened\");\n\n        const buffer = this.extendBuffer(data, this.packetSize);\n\n        // Use endpoint if it exists\n        if (this.endpointOut) {\n            return this.device.transferOut(\n                this.endpointOut.endpointNumber,\n                buffer\n            )\n            .then(() => undefined);\n        }\n\n        // Fallback to using control transfer\n        return this.device.controlTransferOut(\n            {\n                requestType: \"class\",\n                recipient: \"interface\",\n                request: SET_REPORT,\n                value: OUT_REPORT,\n                index: this.interfaceNumber\n            },\n            buffer\n        )\n        .then(() => undefined);\n    }\n}\n"],"names":["EventHandlers","EventEmitter","init","call","this","$getMaxListeners","that","undefined","_maxListeners","defaultMaxListeners","_addListener","target","type","listener","prepend","m","events","existing","e","TypeError","_events","newListener","emit","_eventsCount","unshift","push","warned","length","w","Error","name","emitter","count","console","warn","log","_onceWrap","fired","g","removeListener","apply","arguments","listenerCount","evlistener","arrayClone","arr","i","copy","Array","prototype","Object","create","usingDomains","domain","active","Domain","getPrototypeOf","setMaxListeners","n","isNaN","getMaxListeners","er","handler","len","args","doError","error","err","context","domainEmitter","domainThrown","isFn","self","listeners","emitNone","arg1","emitOne","arg2","emitTwo","arg3","emitThree","emitMany","addListener","on","prependListener","once","prependOnceListener","list","position","originalListener","index","k","pop","spliceOne","removeAllListeners","key","keys","ret","unwrapListeners","eventNames","Reflect","ownKeys","FPBCtrlMask","DEFAULT_CLOCK_FREQUENCY","BLOCK_HEADER_SIZE","TRANSFER_HEADER_SIZE","TRANSFER_OPERATION_SIZE","transport","mode","clockFrequency","_super","_this","blockSize","packetSize","operationSpace","operationCount","Math","floor","tslib_1.__extends","CmsisDAP","timeout","Promise","resolve","_reject","setTimeout","prefix","data","Uint8Array","arrayBuffer","buffer","result","byteLength","set","protocol","sequence","swjSequence","then","Uint16Array","command","array","bufferSourceToUint8Array","write","read","response","getUint8","request","send","getUint16","getUint32","ascii","slice","String","fromCharCode","bitLength","idleCycles","waitRetry","matchRetry","view","DataView","setUint8","setUint16","open","Uint32Array","configureTransfer","selectProtocol","close","disconnect","delay","connect","portOrOps","register","value","operations","port","forEach","operation","offset","setUint32","countOrValues","dataSize","DAPLink","numberArray","bufferString","charCode","charCodeAt","pageSize","end","min","page","EVENT_PROGRESS","writeBuffer","streamType","isBufferBinary","reject","baudrate","serialDelay","stopSerialRead","timer","setInterval","serialData","dataLength","dataArray","EVENT_SERIAL_DATA","clearInterval","arrayData","split","map","transportOrDap","proxy","ADI","fn","running","chain","condition","arrays","arrays_1","_i","j","selectedAddress","address","writeDPCommand","concat","cswValue","writeAPCommand","readAPCommand","merged","splice","this_1","results","transfer","concatTypedArray","readDP","transferSequence","waitDelay","status","reset","readDPCommand","readMem16Command","writeMem16Command","readMem32Command","writeMem32Command","remainder","chunkSize","this_2","transferBlock","values","chunk","this_3","CortexM","writeMem32","readMem32","dhcsr","state","newDhcsr","wait","isHalted","halted","enableDebug","registers","readCoreRegister","code","stackPointer","programCounter","linkRegister","newCode","writeCoreRegisterCommand","halt","writeBlock","resume","deviceOrPath","path","HID","hid","require","device","ex","os","DEFAULT_CONFIGURATION","DEFAULT_CLASS","interfaceClass","configuration","alwaysControlTransfer","USB","bufferSource","Buffer","from","setConfiguration","interfaces","filter","iface","descriptor","bInterfaceClass","selectedInterface","find","endpoints","interfaceNumber","endpointIn","endpointOut","endpoints_1","endpoint","direction","claim","_e","bufferToDataView","controlTransfer","LIBUSB_ENDPOINT_IN","extended","extendBuffer","bufferSourceToBuffer","LIBUSB_ENDPOINT_OUT","WebUSB","selectConfiguration","alternates","claimInterface","transferIn","endpointNumber","controlTransferIn","requestType","recipient","transferOut","controlTransferOut"],"mappings":"ufAOA,SAASA,KAGT,SAASC,IACPA,EAAaC,KAAKC,KAAKC,MA6CzB,SAASC,EAAiBC,GACxB,YAA2BC,IAAvBD,EAAKE,cACAP,EAAaQ,oBACfH,EAAKE,cAqId,SAASE,EAAaC,EAAQC,EAAMC,EAAUC,GAC5C,IAAIC,EACAC,EACAC,EA4DeC,EA1DnB,GAAwB,mBAAbL,EACT,MAAM,IAAIM,UAAU,0CAoBtB,IAlBAH,EAASL,EAAOS,UAOVJ,EAAOK,cACTV,EAAOW,KAAK,cAAeV,EACfC,EAASA,SAAWA,EAASA,SAAWA,GAIpDG,EAASL,EAAOS,SAElBH,EAAWD,EAAOJ,KAblBI,EAASL,EAAOS,QAAU,IAAIpB,EAC9BW,EAAOY,aAAe,GAenBN,GAmBH,GAdwB,mBAAbA,EAETA,EAAWD,EAAOJ,GAAQE,EAAU,CAACD,EAAUI,GACX,CAACA,EAAUJ,GAG3CC,EACFG,EAASO,QAAQX,GAEjBI,EAASQ,KAAKZ,IAKbI,EAASS,SACZX,EAAIV,EAAiBM,KACZI,EAAI,GAAKE,EAASU,OAASZ,EAAG,CACrCE,EAASS,QAAS,EAClB,IAAIE,EAAI,IAAIC,MAAM,+CACEZ,EAASU,OAAS,IAAMf,EAAO,qEAEnDgB,EAAEE,KAAO,8BACTF,EAAEG,QAAUpB,EACZiB,EAAEhB,KAAOA,EACTgB,EAAEI,MAAQf,EAASU,OAQNT,EAPDU,EAQM,mBAAjBK,QAAQC,KAAsBD,QAAQC,KAAKhB,GAAKe,QAAQE,IAAIjB,SApCjED,EAAWD,EAAOJ,GAAQC,IACxBF,EAAOY,aAgCX,OAAOZ,EAgBT,SAASyB,EAAUzB,EAAQC,EAAMC,GAC/B,IAAIwB,GAAQ,EACZ,SAASC,IACP3B,EAAO4B,eAAe3B,EAAM0B,GACvBD,IACHA,GAAQ,EACRxB,EAAS2B,MAAM7B,EAAQ8B,YAI3B,OADAH,EAAEzB,SAAWA,EACNyB,EA2JT,SAASI,EAAc9B,GACrB,IAAII,EAASZ,KAAKgB,QAElB,GAAIJ,EAAQ,CACV,IAAI2B,EAAa3B,EAAOJ,GAExB,GAA0B,mBAAf+B,EACT,OAAO,EACF,GAAIA,EACT,OAAOA,EAAWhB,OAItB,OAAO,EAcT,SAASiB,EAAWC,EAAKC,GAEvB,IADA,IAAIC,EAAO,IAAIC,MAAMF,GACdA,KACLC,EAAKD,GAAKD,EAAIC,GAChB,OAAOC,EAzcT/C,EAAciD,UAAYC,OAAOC,OAAO,MAUxClD,EAAaA,aAAeA,EAE5BA,EAAamD,cAAe,EAE5BnD,EAAagD,UAAUI,YAAS9C,EAChCN,EAAagD,UAAU7B,aAAUb,EACjCN,EAAagD,UAAUzC,mBAAgBD,EAIvCN,EAAaQ,oBAAsB,GAEnCR,EAAaC,KAAO,WAClBE,KAAKiD,OAAS,KACVpD,EAAamD,oBA9BfC,GAgCWC,cAhCXD,GAgC8CE,OAK3CnD,KAAKgB,SAAWhB,KAAKgB,UAAY8B,OAAOM,eAAepD,MAAMgB,UAChEhB,KAAKgB,QAAU,IAAIpB,EACnBI,KAAKmB,aAAe,GAGtBnB,KAAKI,cAAgBJ,KAAKI,oBAAiBD,GAK7CN,EAAagD,UAAUQ,gBAAkB,SAAyBC,GAChE,GAAiB,iBAANA,GAAkBA,EAAI,GAAKC,MAAMD,GAC1C,MAAM,IAAIvC,UAAU,0CAEtB,OADAf,KAAKI,cAAgBkD,EACdtD,MASTH,EAAagD,UAAUW,gBAAkB,WACvC,OAAOvD,EAAiBD,OA4D1BH,EAAagD,UAAU3B,KAAO,SAAcV,GAC1C,IAAIiD,EAAIC,EAASC,EAAKC,EAAMlB,EAAG9B,EAAQqC,EAEnCY,EAAoB,UAATrD,EAGf,GADAI,EAASZ,KAAKgB,QAEZ6C,EAAWA,GAA2B,MAAhBjD,EAAOkD,WAC1B,IAAKD,EACR,OAAO,EAKT,GAHAZ,EAASjD,KAAKiD,OAGVY,EAAS,CAEX,GADAJ,EAAKpB,UAAU,IACXY,EAOG,CAAA,GAAIQ,aAAchC,MACvB,MAAMgC,EAGN,IAAIM,EAAM,IAAItC,MAAM,yCAA2CgC,EAAK,KAEpE,MADAM,EAAIC,QAAUP,EACRM,EAER,OAdON,IACHA,EAAK,IAAIhC,MAAM,wCACjBgC,EAAGQ,cAAgBjE,KACnByD,EAAGR,OAASA,EACZQ,EAAGS,cAAe,EAClBjB,EAAO/B,KAAK,QAASuC,IAShB,EAKT,KAFAC,EAAU9C,EAAOJ,IAGf,OAAO,EAET,IAAI2D,EAA0B,mBAAZT,EAElB,OADAC,EAAMtB,UAAUd,QAGd,KAAK,GA/FT,SAAkBmC,EAASS,EAAMC,GAC/B,GAAID,EACFT,EAAQ3D,KAAKqE,QAIb,IAFA,IAAIT,EAAMD,EAAQnC,OACd8C,EAAY7B,EAAWkB,EAASC,GAC3BjB,EAAI,EAAGA,EAAIiB,IAAOjB,EACzB2B,EAAU3B,GAAG3C,KAAKqE,GAyFlBE,CAASZ,EAASS,EAAMnE,MACxB,MACF,KAAK,GAxFT,SAAiB0D,EAASS,EAAMC,EAAMG,GACpC,GAAIJ,EACFT,EAAQ3D,KAAKqE,EAAMG,QAInB,IAFA,IAAIZ,EAAMD,EAAQnC,OACd8C,EAAY7B,EAAWkB,EAASC,GAC3BjB,EAAI,EAAGA,EAAIiB,IAAOjB,EACzB2B,EAAU3B,GAAG3C,KAAKqE,EAAMG,GAkFxBC,CAAQd,EAASS,EAAMnE,KAAMqC,UAAU,IACvC,MACF,KAAK,GAjFT,SAAiBqB,EAASS,EAAMC,EAAMG,EAAME,GAC1C,GAAIN,EACFT,EAAQ3D,KAAKqE,EAAMG,EAAME,QAIzB,IAFA,IAAId,EAAMD,EAAQnC,OACd8C,EAAY7B,EAAWkB,EAASC,GAC3BjB,EAAI,EAAGA,EAAIiB,IAAOjB,EACzB2B,EAAU3B,GAAG3C,KAAKqE,EAAMG,EAAME,GA2E9BC,CAAQhB,EAASS,EAAMnE,KAAMqC,UAAU,GAAIA,UAAU,IACrD,MACF,KAAK,GA1ET,SAAmBqB,EAASS,EAAMC,EAAMG,EAAME,EAAME,GAClD,GAAIR,EACFT,EAAQ3D,KAAKqE,EAAMG,EAAME,EAAME,QAI/B,IAFA,IAAIhB,EAAMD,EAAQnC,OACd8C,EAAY7B,EAAWkB,EAASC,GAC3BjB,EAAI,EAAGA,EAAIiB,IAAOjB,EACzB2B,EAAU3B,GAAG3C,KAAKqE,EAAMG,EAAME,EAAME,GAoEpCC,CAAUlB,EAASS,EAAMnE,KAAMqC,UAAU,GAAIA,UAAU,GAAIA,UAAU,IACrE,MAEF,QAEE,IADAuB,EAAO,IAAIhB,MAAMe,EAAM,GAClBjB,EAAI,EAAGA,EAAIiB,EAAKjB,IACnBkB,EAAKlB,EAAI,GAAKL,UAAUK,IAtEhC,SAAkBgB,EAASS,EAAMC,EAAMR,GACrC,GAAIO,EACFT,EAAQtB,MAAMgC,EAAMR,QAIpB,IAFA,IAAID,EAAMD,EAAQnC,OACd8C,EAAY7B,EAAWkB,EAASC,GAC3BjB,EAAI,EAAGA,EAAIiB,IAAOjB,EACzB2B,EAAU3B,GAAGN,MAAMgC,EAAMR,GAgEzBiB,CAASnB,EAASS,EAAMnE,KAAM4D,GAMlC,OAAO,GAqET/D,EAAagD,UAAUiC,YAAc,SAAqBtE,EAAMC,GAC9D,OAAOH,EAAaN,KAAMQ,EAAMC,GAAU,IAG5CZ,EAAagD,UAAUkC,GAAKlF,EAAagD,UAAUiC,YAEnDjF,EAAagD,UAAUmC,gBACnB,SAAyBxE,EAAMC,GAC7B,OAAOH,EAAaN,KAAMQ,EAAMC,GAAU,IAgBhDZ,EAAagD,UAAUoC,KAAO,SAAczE,EAAMC,GAChD,GAAwB,mBAAbA,EACT,MAAM,IAAIM,UAAU,0CAEtB,OADAf,KAAK+E,GAAGvE,EAAMwB,EAAUhC,KAAMQ,EAAMC,IAC7BT,MAGTH,EAAagD,UAAUqC,oBACnB,SAA6B1E,EAAMC,GACjC,GAAwB,mBAAbA,EACT,MAAM,IAAIM,UAAU,0CAEtB,OADAf,KAAKgF,gBAAgBxE,EAAMwB,EAAUhC,KAAMQ,EAAMC,IAC1CT,MAIbH,EAAagD,UAAUV,eACnB,SAAwB3B,EAAMC,GAC5B,IAAI0E,EAAMvE,EAAQwE,EAAU1C,EAAG2C,EAE/B,GAAwB,mBAAb5E,EACT,MAAM,IAAIM,UAAU,0CAGtB,KADAH,EAASZ,KAAKgB,SAEZ,OAAOhB,KAGT,KADAmF,EAAOvE,EAAOJ,IAEZ,OAAOR,KAET,GAAImF,IAAS1E,GAAa0E,EAAK1E,UAAY0E,EAAK1E,WAAaA,EAC/B,KAAtBT,KAAKmB,aACTnB,KAAKgB,QAAU,IAAIpB,UAEZgB,EAAOJ,GACVI,EAAOuB,gBACTnC,KAAKkB,KAAK,iBAAkBV,EAAM2E,EAAK1E,UAAYA,SAElD,GAAoB,mBAAT0E,EAAqB,CAGrC,IAFAC,GAAY,EAEP1C,EAAIyC,EAAK5D,OAAQmB,KAAM,GAC1B,GAAIyC,EAAKzC,KAAOjC,GACX0E,EAAKzC,GAAGjC,UAAY0E,EAAKzC,GAAGjC,WAAaA,EAAW,CACvD4E,EAAmBF,EAAKzC,GAAGjC,SAC3B2E,EAAW1C,EACX,MAIJ,GAAI0C,EAAW,EACb,OAAOpF,KAET,GAAoB,IAAhBmF,EAAK5D,OAAc,CAErB,GADA4D,EAAK,QAAKhF,EACkB,KAAtBH,KAAKmB,aAET,OADAnB,KAAKgB,QAAU,IAAIpB,EACZI,YAEAY,EAAOJ,QAiH1B,SAAmB2E,EAAMG,GACvB,IAAK,IAAI5C,EAAI4C,EAAOC,EAAI7C,EAAI,EAAGY,EAAI6B,EAAK5D,OAAQgE,EAAIjC,EAAGZ,GAAK,EAAG6C,GAAK,EAClEJ,EAAKzC,GAAKyC,EAAKI,GACjBJ,EAAKK,MAjHGC,CAAUN,EAAMC,GAGdxE,EAAOuB,gBACTnC,KAAKkB,KAAK,iBAAkBV,EAAM6E,GAAoB5E,GAG1D,OAAOT,MAGbH,EAAagD,UAAU6C,mBACnB,SAA4BlF,GAC1B,IAAI6D,EAAWzD,EAGf,KADAA,EAASZ,KAAKgB,SAEZ,OAAOhB,KAGT,IAAKY,EAAOuB,eAUV,OATyB,IAArBE,UAAUd,QACZvB,KAAKgB,QAAU,IAAIpB,EACnBI,KAAKmB,aAAe,GACXP,EAAOJ,KACY,KAAtBR,KAAKmB,aACTnB,KAAKgB,QAAU,IAAIpB,SAEZgB,EAAOJ,IAEXR,KAIT,GAAyB,IAArBqC,UAAUd,OAAc,CAE1B,IADA,IACgBoE,EADZC,EAAO9C,OAAO8C,KAAKhF,GACd8B,EAAI,EAAQA,EAAIkD,EAAKrE,SAAUmB,EAE1B,oBADZiD,EAAMC,EAAKlD,KAEX1C,KAAK0F,mBAAmBC,GAK1B,OAHA3F,KAAK0F,mBAAmB,kBACxB1F,KAAKgB,QAAU,IAAIpB,EACnBI,KAAKmB,aAAe,EACbnB,KAKT,GAAyB,mBAFzBqE,EAAYzD,EAAOJ,IAGjBR,KAAKmC,eAAe3B,EAAM6D,QACrB,GAAIA,EAET,GACErE,KAAKmC,eAAe3B,EAAM6D,EAAUA,EAAU9C,OAAS,UAChD8C,EAAU,IAGrB,OAAOrE,MAGbH,EAAagD,UAAUwB,UAAY,SAAmB7D,GACpD,IAAI+B,EAEA3B,EAASZ,KAAKgB,QAclB,OAZKJ,IAGH2B,EAAa3B,EAAOJ,IAGW,mBAAf+B,EACR,CAACA,EAAW9B,UAAY8B,GAmDpC,SAAyBE,GAEvB,IADA,IAAIoD,EAAM,IAAIjD,MAAMH,EAAIlB,QACfmB,EAAI,EAAGA,EAAImD,EAAItE,SAAUmB,EAChCmD,EAAInD,GAAKD,EAAIC,GAAGjC,UAAYgC,EAAIC,GAElC,OAAOmD,EAtDGC,CAAgBvD,GARlB,IAcV1C,EAAayC,cAAgB,SAASX,EAASnB,GAC7C,MAAqC,mBAA1BmB,EAAQW,cACVX,EAAQW,cAAc9B,GAEtB8B,EAAcvC,KAAK4B,EAASnB,IAIvCX,EAAagD,UAAUP,cAAgBA,EAiBvCzC,EAAagD,UAAUkD,WAAa,WAClC,OAAO/F,KAAKmB,aAAe,EAAI6E,QAAQC,QAAQjG,KAAKgB,SAAW,QCnIrDkF,ECvRCC,EAA0B,IAajCC,EAAoB,EAIpBC,EAAuB,EAIvBC,EAA0B,gBAwB5B,WAAoBC,EAA8BC,EAAiDC,gBAAjDD,kBAAiDC,KAAnG,MACIC,mBADgBC,YAAAJ,EAA8BI,OAAAH,EAAiDG,iBAAAF,EAI/FE,EAAKC,UAAYD,EAAKJ,UAAUM,WAAaT,EAAoB,EAGjE,IAAMU,EAAiBH,EAAKJ,UAAUM,WAAaR,EAAuB,SAC1EM,EAAKI,eAAiBC,KAAKC,MAAMH,EAAiBR,KAiW1D,OA3X8BY,OA6BlBC,kBAAR,SAAcC,GACV,OAAO,IAAIC,QAAQ,SAACC,EAASC,GACzBC,WAAWF,EAASF,MAIpBD,qCAAR,SAAiCM,EAAgBC,GAE7C,IAAKA,EACD,OAAO,IAAIC,WAAW,CAACF,IAO3B,IAAMG,OAH4CzH,IAGvBuH,EAHYG,OAGJH,EAAKG,OAASH,EAC3CI,EAAS,IAAIH,WAAWC,EAAYG,WAAa,GAKvD,OAHAD,EAAOE,IAAI,CAACP,IACZK,EAAOE,IAAI,IAAIL,WAAWC,GAAc,GAEjCE,GAODX,2BAAV,SAAyBc,GAAzB,WACUC,MAAWD,EA9EH,MAJD,MAoFb,OAAOjI,KAAKmI,YAAY,IAAIR,WAAW,CAAC,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,OAC3ES,KAAK,WAAM,OAAAzB,EAAKwB,YAAY,IAAIE,YAAY,CAACH,OAC7CE,KAAK,WAAM,OAAAzB,EAAKwB,YAAY,IAAIR,WAAW,CAAC,IAAM,IAAM,IAAM,IAAM,IAAM,IAAM,SAChFS,KAAK,WAAM,OAAAzB,EAAKwB,YAAY,IAAIR,WAAW,CAAC,QASvCR,iBAAV,SAAemB,EAAiBZ,GAAhC,WACUa,EAAQvI,KAAKwI,yBAAyBF,EAASZ,GAErD,OAAO1H,KAAKuG,UAAUkC,MAAMF,GAC3BH,KAAK,WAAM,OAAAzB,EAAKJ,UAAUmC,SAC1BN,KAAK,SAAAO,GACF,GAAIA,EAASC,SAAS,KAAON,EACzB,MAAM,IAAI7G,MAAM,oBAAoB6G,SAAcK,EAASC,SAAS,IAGxE,OAAQN,GACJ,OACA,OACA,OACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,OACI,OAAIK,EAASC,SAAS,GAClB,MAAM,IAAInH,MAAM,kBAAkB6G,SAAcK,EAASC,SAAS,IAI9E,OAAOD,KASRxB,oBAAP,SAAe0B,GACX,OAAO7I,KAAK8I,OAA0B,IAAInB,WAAW,CAACkB,KACrDT,KAAK,SAAAN,GACF,IAAMvG,EAASuG,EAAOc,SAAS,GAE/B,GAAe,IAAXrH,EACA,MAAM,IAAIE,MAAM,oBAGpB,OAAQoH,GACJ,SACA,SACA,SACA,SAEI,GAAe,IAAXtH,EAAc,OAAOuG,EAAOc,SAAS,GAGzC,GAAe,IAAXrH,EAAc,OAAOuG,EAAOiB,UAAU,GAG1C,GAAe,IAAXxH,EAAc,OAAOuG,EAAOkB,UAAU,GAGlD,IAAMC,EAAQrG,MAAMC,UAAUqG,MAAMnJ,KAAK,IAAI4H,WAAWG,EAAOD,OAAQ,EAAGtG,IAC1E,OAAO4H,OAAOC,aAAahH,MAAM,KAAM6G,MAUxC9B,wBAAP,SAAmBe,GACf,IAAMmB,EAAkC,EAAtBnB,EAASH,WACrBL,EAAO1H,KAAKwI,yBAAyBa,EAAWnB,GAEtD,OAAOlI,KAAK8I,QAAkCpB,GAC7CU,KAAK,eAWHjB,8BAAP,SAAyBmC,EAAoBC,EAAmBC,GAC5D,IAAM9B,EAAO,IAAIC,WAAW,GACtB8B,EAAO,IAAIC,SAAShC,EAAKG,QAM/B,OAJA4B,EAAKE,SAAS,EAAGL,GACjBG,EAAKG,UAAU,EAAGL,GAAW,GAC7BE,EAAKG,UAAU,EAAGJ,GAAY,GAEvBxJ,KAAK8I,OAAwCpB,GACnDU,KAAK,eAOHjB,oBAAP,WAAA,WACI,OAAOnH,KAAKuG,UAAUsD,OACrBzB,KAAK,WAAM,OAAAzB,EAAKmC,QAA+B,IAAIgB,YAAY,CAACnD,EAAKF,oBACrE2B,KAAK,WAAM,OAAAzB,EAAKmC,OAA6B,IAAInB,WAAW,CAAChB,EAAKH,UAClE4B,KAAK,SAAAN,GACF,OAAIA,EAAOc,SAAS,QAAoCjC,EAAKH,MAAgCsB,EAAOc,SAAS,KAAOjC,EAAKH,KACrH,MAAM,IAAI/E,MAAM,uBAGvB2G,KAAK,WAAM,OAAAzB,EAAKoD,kBAAkB,EAAG,IAAK,KAC1C3B,KAAK,WAAM,OAAAzB,EAAKqD,qBAOd7C,uBAAP,WAAA,WACI,OAAOnH,KAAK8I,QACXV,KAAK,WACF,OAAOzB,EAAKJ,UAAU0D,WAQvB9C,sBAAP,WAAA,WACI,OAAOnH,KAAKkK,aACX9B,KAAK,WAAM,OAAAzB,EAAKwD,MAAM,OACtB/B,KAAK,WAAM,OAAAzB,EAAKyD,aAOdjD,kBAAP,WACI,OAAOnH,KAAK8I,SACXV,KAAK,SAAAO,GAAY,WAAAA,EAASC,SAAS,MAkBjCzB,qBAAP,SAAgBkD,EAAqC7D,EAA8C8D,EAAsBC,GAErH,IAAIC,eAF6ChE,kBAA8C8D,kBAAsBC,KAKjHC,EADqB,iBAAdH,EACM,CAAC,CACVI,KAAMJ,EACN7D,OACA8D,WACAC,UAGSF,EAGjB,IAAM3C,EAAO,IAAIC,WAAWtB,EAAwBmE,EAAWjJ,OAAS+E,GAClEmD,EAAO,IAAIC,SAAShC,EAAKG,QAgB/B,OAbA4B,EAAKE,SAAS,EAAG,GAEjBF,EAAKE,SAAS,EAAGa,EAAWjJ,QAE5BiJ,EAAWE,QAAQ,SAACC,EAAWrF,GAC3B,IAAMsF,EAASvE,EAAwBf,EAAQgB,EAG/CmD,EAAKE,SAASiB,EAAQD,EAAUF,KAAOE,EAAUnE,KAAOmE,EAAUL,UAElEb,EAAKoB,UAAUD,EAAS,EAAGD,EAAUJ,OAAS,GAAG,KAG9CvK,KAAK8I,OAA8BpB,GACzCU,KAAK,SAAAN,GAGF,GAAIA,EAAOc,SAAS,KAAO4B,EAAWjJ,OAClC,MAAM,IAAIE,MAAM,2BAIpB,IAAMkH,EAAWb,EAAOc,SAAS,GACjC,OAAID,EACA,MAAM,IAAIlH,MAAM,0BAEpB,OAAIkH,EACA,MAAM,IAAIlH,MAAM,2BAEpB,OAAIkH,EACA,MAAM,IAAIlH,MAAM,oCAEpB,QAAIkH,EACA,MAAM,IAAIlH,MAAM,oCAEpB,OAAIkH,EACA,MAAM,IAAIlH,MAAM,4BAGpB,GAAyB,iBAAd4I,EACP,OAAOvC,EAAOkB,UAAU,GAAG,GAG/B,IAAMzH,EAA6B,EAApBiJ,EAAWjJ,OAC1B,OAAO,IAAIuI,YAAYhC,EAAOD,OAAOqB,MAAM,EAAG,EAAI3H,OAmBnD4F,0BAAP,SAAqBsD,EAAeH,EAAkBQ,GAElD,IAAI/D,EACAP,EACAuE,EAAW3E,EAEc,iBAAlB0E,GACP/D,EAAiB+D,EACjBtE,MAEAO,EAAiB+D,EAAcvJ,OAC/BiF,IACAuE,GAAYD,EAAc/C,YAG9B,IAAML,EAAO,IAAIC,WAAWoD,GACtBtB,EAAO,IAAIC,SAAShC,EAAKG,QAc/B,OAXA4B,EAAKE,SAAS,EAAG,GAEjBF,EAAKG,UAAU,EAAG7C,GAAgB,GAElC0C,EAAKE,SAAS,EAAGc,EAAOjE,EAAO8D,GAEF,iBAAlBQ,GAEPpD,EAAKM,IAAI8C,EAAe1E,GAGrBpG,KAAK8I,OAAoCW,GAC/CrB,KAAK,SAAAN,GAGF,GAAIA,EAAOiB,UAAU,GAAG,KAAUhC,EAC9B,MAAM,IAAItF,MAAM,2BAIpB,IAAMkH,EAAWb,EAAOc,SAAS,GACjC,KAAID,EACA,MAAM,IAAIlH,MAAM,0BAEpB,KAAIkH,EACA,MAAM,IAAIlH,MAAM,2BAEpB,KAAIkH,EACA,MAAM,IAAIlH,MAAM,oCAEpB,KAAIkH,EACA,MAAM,IAAIlH,MAAM,4BAGpB,GAA6B,iBAAlBqJ,EACP,OAAO,IAAIhB,YAAYhC,EAAOD,OAAOqB,MAAM,UArX7BrJ,iBC1B9B,4DAwJA,OAxJ6BqH,OAmBjB8D,2BAAR,SAAuBnD,GAInB,IAHA,IAAMoD,EAAcrI,MAAMC,UAAUqG,MAAMnJ,KAAK,IAAIsI,YAAYR,EAAQ,EAAG,KACpEqD,EAAuB/B,OAAOC,aAAahH,MAAM,KAAM6I,GAEpDvI,EAAI,EAAGA,EAAIwI,EAAa3J,OAAQmB,IAAK,CAC1C,IAAMyI,EAAWD,EAAaE,WAAW1I,GAGzC,GAAiB,QAAbyI,GAAsBA,GAAY,EAClC,OAAO,EAGf,OAAO,GAGHH,wBAAR,SAAoBnD,EAAqBwD,EAAkBT,GAA3D,wBAA2DA,KACvD,IAAMU,EAAMtE,KAAKuE,IAAI1D,EAAOE,WAAY6C,EAASS,GAC3CG,EAAO3D,EAAOqB,MAAM0B,EAAQU,GAC5B5D,EAAO,IAAIC,WAAW6D,EAAKzD,WAAa,GAK9C,OAHAL,EAAKM,IAAI,CAACwD,EAAKzD,aACfL,EAAKM,IAAI,IAAIL,WAAW6D,GAAO,GAExBxL,KAAK8I,SAAyBpB,GACpCU,KAAK,WAEF,OADAzB,EAAKzF,KAAK8J,EAAQS,eAAgBb,EAAS/C,EAAOE,YAC9CuD,EAAMzD,EAAOE,WACNpB,EAAK+E,YAAY7D,EAAQwD,EAAUC,GAEvCjE,QAAQC,aAUhB0D,kBAAP,SAAanD,EAAsBwD,GAAnC,wBAAmCA,EA/Db,IAoElB,IAAMzD,OAH4CzH,IAGvB0H,EAHYA,OAGFA,EAAOA,OAASA,EAC/C8D,EAAa3L,KAAK4L,eAAehE,GAAe,EAAI,EAE1D,OAAO5H,KAAK8I,SAAwB,IAAIgB,YAAY,CAAC6B,KACpDvD,KAAK,SAAAN,GAEF,OAA2B,IAAvBA,EAAOc,SAAS,GAAiBvB,QAAQwE,OAAO,eAC7ClF,EAAK+E,YAAY9D,EAAayD,KAExCjD,KAAK,WAEF,OADAzB,EAAKzF,KAAK8J,EAAQS,eAAgB,GAC3B9E,EAAKmC,YAEfV,KAAK,SAAAN,GAEF,OAA2B,IAAvBA,EAAOc,SAAS,GAAiBvB,QAAQwE,OAAO,eAC7ClF,EAAKmC,YAEfV,KAAK,eAOH4C,8BAAP,WACI,OAAOhL,KAAK8I,UACXV,KAAK,SAAAN,GACF,OAAOA,EAAOkB,UAAU,GAAG,MAS5BgC,8BAAP,SAAyBc,GACrB,oBADqBA,EAjHJ,MAkHV9L,KAAK8I,SAAmC,IAAIgB,YAAY,CAACgC,KAC/D1D,KAAK,eAOH4C,4BAAP,SAAuBe,GAAvB,wBAAuBA,EAtHE,KAuHrB/L,KAAKgM,iBACLhM,KAAKiM,MAAQC,YAAY,WACrB,OAAOvF,EAAKmC,UACXV,KAAK,SAAA+D,GACF,GAAIA,EAAWpE,WAAa,EAAG,CAI3B,IAAMqE,EAAaD,EAAWvD,SAAS,GACvC,GAAmB,IAAfwD,EAAkB,CAClB,IACMC,EAAYF,EAAWtE,OAAOqB,MADrB,EAAA,EAC4CkD,GACrDnB,EAAcrI,MAAMC,UAAUqG,MAAMnJ,KAAK,IAAI4H,WAAW0E,IACxD3E,EAAOyB,OAAOC,aAAahH,MAAM,KAAM6I,GAC7CtE,EAAKzF,KAAK8J,EAAQsB,kBAAmB5E,QAIlDqE,IAMAf,2BAAP,WACQhL,KAAKiM,QACLM,cAAcvM,KAAKiM,OACnBjM,KAAKiM,WAAQ9L,IASd6K,wBAAP,SAAmBtD,GACf,IAAM8E,EAAY9E,EAAK+E,MAAM,IAAIC,IAAI,SAAC5L,GAAc,OAAAA,EAAEsK,WAAW,KAEjE,OADAoB,EAAUpL,QAAQoL,EAAUjL,QACrBvB,KAAK8I,SAA0B,IAAInB,WAAW6E,GAAW3E,QAC/DO,KAAK,eAhJI4C,iBAAyB,WAMzBA,oBAA4B,YAZjB7D,gBCSzB,WAAYwF,EAAmCnG,EAAyCC,gBAAzCD,kBAAyCC,KAIpFzG,KAAK4M,WAFmCzM,IAEfwM,EAFM9C,KAEY,IAAI1C,EAASwF,EAAgBnG,EAAMC,GAAkBkG,EA+UxG,OA5UcE,kBAAV,SAAgBzF,GACZ,OAAO,IAAIC,QAAQ,SAACC,EAASC,GACzBC,WAAWF,EAASF,MAWlByF,sBAAV,SAAoBC,EAA4Bb,EAAqB7E,GAArE,wBAAgD6E,oBAAqB7E,KACjE,IAAI2F,GAAmB,EAEjBC,EAAQ,SAACC,GACX,OAAKF,EACEE,EACD5F,QAAQC,UACRX,EAAKwD,MAAM8B,GACZ7D,KAAK0E,GACL1E,KAAK4E,GALW3F,QAAQC,WAQjC,OAAO,IAAID,QAAQ,SAACC,EAASuE,GAQzB,OAPIzE,EAAU,GACVI,WAAW,WACPuF,GAAU,EACVlB,EAAO,mBACRzE,GAGA4F,GAAM,GACZ5E,KAAK,WAAM,OAAAd,SAIVuF,6BAAV,SAA2BK,GAEvB,GAAsB,IAAlBA,EAAO3L,OAAc,OAAO2L,EAAO,GAIvC,IADA,IAAI3L,EAAiB,MACD4L,IAAAC,WAAAA,IAAQ,CACxB7L,QAAgBA,OAKpB,IADA,IAAMuG,EAAS,IAAIgC,YAAYvI,GACtBmB,EAAI,EAAG2K,EAAI,EAAG3K,EAAIwK,EAAO3L,OAAQmB,IACtCoF,EAAOE,IAAIkF,EAAOxK,GAAI2K,GACtBA,GAAKH,EAAOxK,GAAGnB,OAGnB,OAAOuG,GAGD+E,0BAAV,SAAwBvC,GACpB,MAAO,CAAC,CACJ9D,OACAiE,OACAH,cAIEuC,2BAAV,SAAyBvC,EAAkBC,GACvC,OAAID,EAAgC,CAChC,GAAIC,IAAUvK,KAAKsN,gBACf,MAAO,GAEXtN,KAAKsN,gBAAkB/C,EAG3B,MAAO,CAAC,CACJ/D,OACAiE,OACAH,WACAC,WAIEsC,0BAAV,SAAwBvC,GACpB,IAAMiD,aAAWjD,MAAoCA,EAErD,OAAOtK,KAAKwN,iBAAkCD,GAASE,OAAO,CAC1DjH,OACAiE,OACAH,cAIEuC,2BAAV,SAAyBvC,EAAkBC,GACvC,OAAID,EAA6B,CAC7B,GAAIC,IAAUvK,KAAK0N,SACf,MAAO,GAEX1N,KAAK0N,SAAWnD,EAGpB,IAAMgD,aAAWjD,MAAoCA,EAErD,OAAOtK,KAAKwN,iBAAkCD,GAASE,OAAO,CAC1DjH,OACAiE,OACAH,WACAC,WAIEsC,6BAAV,SAA2BvC,GACvB,OAAOtK,KAAK2N,iBAA+B,WAC1CF,OAAOzN,KAAK2N,iBAA+BrD,IAC3CmD,OAAOzN,KAAK4N,oBAGPf,8BAAV,SAA4BvC,EAAkBC,GAC1C,OAAOvK,KAAK2N,iBAA+B,WAC1CF,OAAOzN,KAAK2N,iBAA+BrD,IAC3CmD,OAAOzN,KAAK2N,kBAA+BpD,KAGtCsC,6BAAV,SAA2BvC,GACvB,OAAOtK,KAAK2N,iBAA+B,WAC1CF,OAAOzN,KAAK2N,iBAA+BrD,IAC3CmD,OAAOzN,KAAK4N,oBAGPf,8BAAV,SAA4BvC,EAAkBC,GAC1C,OAAOvK,KAAK2N,iBAA+B,WAC1CF,OAAOzN,KAAK2N,iBAA+BrD,IAC3CmD,OAAOzN,KAAK2N,kBAA+BpD,KAGtCsC,6BAAV,SAA2BrC,GAA3B,WAEQqD,EAAyB,GAC7BA,EAASA,EAAOJ,aAAPI,EAAiBrD,GAK1B,IAHA,IAAIwC,EAAgC3F,QAAQC,QAAQ,iBAIhD,IAAMY,EAAW2F,EAAOC,OAAO,EAAGC,EAAKnB,MAAM7F,gBAC7CiG,EAAQA,EAAM5E,KAAK,SAAA4F,GAAW,OAAArH,EAAKiG,MAAMqB,SAAS/F,GAAUE,KAAK,SAAAN,GAAU,OAAIkG,UAASlG,gBAFrF+F,EAAOtM,YAKd,OAAOyL,EACN5E,KAAK,SAAA8E,GAAU,OAAAvG,EAAKuH,iBAAiBhB,MAOnCL,oBAAP,WAAA,WAGI,OAAO7M,KAAK4M,MAAMxC,UACjBhC,KAAK,WAAM,OAAAzB,EAAKwH,YAChB/F,KAAK,WAAM,OAAAzB,EAAKyH,iBAAiB,CAC9BzH,EAAK6G,oBACL7G,EAAK6G,oBACL7G,EAAK6G,iBAAqC,gBAG7CpF,KAAK,WAAM,OAAAzB,EAAK0H,UAAU,WACvB,OAAO1H,EAAKwH,UACX/F,KAAK,SAAAkG,GAAU,OAZP,cAAA,WAYSA,UAQnBzB,uBAAP,WACI,OAAO7M,KAAK4M,MAAM1C,cAOf2C,sBAAP,WAAA,WACI,OAAO7M,KAAKkK,aACX9B,KAAK,WAAM,OAAAzB,EAAKwD,MAAM,OACtB/B,KAAK,WAAM,OAAAzB,EAAKyD,aAOdyC,kBAAP,WACI,OAAO7M,KAAK4M,MAAM2B,SAQf1B,mBAAP,SAAcvC,GACV,OAAOtK,KAAK4M,MAAMqB,SAASjO,KAAKwO,cAAclE,IAC7ClC,KAAK,SAAAN,GAAU,OAAAA,EAAO,MASpB+E,oBAAP,SAAevC,EAAsBC,GACjC,OAAOvK,KAAK4M,MAAMqB,SAASjO,KAAKwN,eAAelD,EAAUC,IACxDnC,KAAK,eAQHyE,mBAAP,SAAcvC,GACV,OAAOtK,KAAK4M,MAAMqB,SAASjO,KAAK4N,cAActD,IAC7ClC,KAAK,SAAAN,GAAU,OAAAA,EAAO,MASpB+E,oBAAP,SAAevC,EAAsBC,GACjC,OAAOvK,KAAK4M,MAAMqB,SAASjO,KAAK2N,eAAerD,EAAUC,IACxDnC,KAAK,eAQHyE,sBAAP,SAAiBvC,GACb,OAAOtK,KAAK4M,MAAMqB,SAASjO,KAAKyO,iBAAiBnE,IAChDlC,KAAK,SAAAN,GAAU,OAAAA,EAAO,MASpB+E,uBAAP,SAAkBvC,EAAkBC,GAEhC,OADAA,KAAwC,EAAXD,IAAoB,EAC1CtK,KAAK4M,MAAMqB,SAASjO,KAAK0O,kBAAkBpE,EAAUC,IAC3DnC,KAAK,eAQHyE,sBAAP,SAAiBvC,GACb,OAAOtK,KAAK4M,MAAMqB,SAASjO,KAAK2O,iBAAiBrE,IAChDlC,KAAK,SAAAN,GAAU,OAAAA,EAAO,MASpB+E,uBAAP,SAAkBvC,EAAkBC,GAChC,OAAOvK,KAAK4M,MAAMqB,SAASjO,KAAK4O,kBAAkBtE,EAAUC,IAC3DnC,KAAK,eASHyE,sBAAP,SAAiBvC,EAAkB1I,GAS/B,IATJ,WACQoL,EAAgChN,KAAKoO,iBAAiB,CACtDpO,KAAK2N,iBAA+B,WACpC3N,KAAK2N,iBAA+BrD,KAEvClC,KAAK,WAAM,MAAA,KAGRyG,EAAYjN,eAEZ,IAAMkN,EAAY9H,KAAKuE,IAAIsD,EAAWE,EAAKnC,MAAMhG,WACjDoG,EAAQA,EAAM5E,KAAK,SAAA4F,GAAW,OAAArH,EAAKiG,MAAMoC,mBAA8CF,GACtF1G,KAAK,SAAAN,GAAU,OAAIkG,UAASlG,QAC7B+G,GAAaC,UAJVD,EAAY,OAOnB,OAAO7B,EACN5E,KAAK,SAAA8E,GAAU,OAAAvG,EAAKuH,iBAAiBhB,MASnCL,uBAAP,SAAkBvC,EAAkB2E,GAShC,IATJ,WACQjC,EAAuBhN,KAAKoO,iBAAiB,CAC7CpO,KAAK2N,iBAA+B,WACpC3N,KAAK2N,iBAA+BrD,KAEvClC,KAAK,cAGF9C,EAAQ,eAER,IAAM4J,EAAQD,EAAO/F,MAAM5D,EAAOA,EAAQ6J,EAAKvC,MAAMhG,WACrDoG,EAAQA,EAAM5E,KAAK,WAAM,OAAAzB,EAAKiG,MAAMoC,mBAA8CE,KAClF5J,GAAS6J,EAAKvC,MAAMhG,kBAHjBtB,EAAQ2J,EAAO1N,YAMtB,OAAOyL,sBCjVf,4DA+LA,OA/L6B9F,OAEjBkI,wBAAR,WACI,OAAOpP,KAAKqP,uBAAgC,aAGtCD,oCAAV,SAAkC9E,GAC9B,OAAOtK,KAAK4O,6BAAuCtE,GAClDmD,OAAOzN,KAAK2O,8BACZlB,OAAOzN,KAAK2O,+BAGPS,qCAAV,SAAmC9E,EAAkBC,GACjD,OAAOvK,KAAK4O,6BAAuCrE,GAClDkD,OAAOzN,KAAK4O,mCAAuCtE,KAOjD8E,qBAAP,WAAA,WACI,OAAOpP,KAAKsP,sBACXlH,KAAK,SAAAmH,GACF,IAAIC,EAOJ,OALgCA,SAA5BD,WACKA,WACAA,eAGLA,EAEO5I,EAAK2I,sBACXlH,KAAK,SAAAqH,GACF,gBAAIA,cAAqCA,KAG9BD,IAIRA,KASZJ,qBAAP,WACI,OAAOpP,KAAKsP,sBACXlH,KAAK,SAAAmH,GACF,gBAAUA,MAUXH,iBAAP,SAAYM,EAAsBtI,GAAlC,WACI,oBADQsI,mBAAsBtI,KACvBpH,KAAK2P,WACXvH,KAAK,SAAAwH,GACF,OAAIA,EAAevI,QAAQC,UAEpBX,EAAK0I,uBAAgC,YAC3CjH,KAAK,WACF,OAAKsH,EAEE/I,EAAK0H,UAAU,WAAM,OAAA1H,EAAKgJ,YAAY,IAAKvI,GAFhCC,QAAQC,eAa/B8H,mBAAP,SAAcM,EAAsBtI,GAApC,WACI,oBADUsI,mBAAsBtI,KACzBpH,KAAK2P,WACXvH,KAAK,SAAAwH,GACF,OAAKA,EAEEjJ,EAAK0I,sBAA+B,GAC1CjH,KAAK,WAAM,OAAAzB,EAAKkJ,gBAChBzH,KAAK,WACF,OAAKsH,EAEE/I,EAAK0H,UAAU,WAAM,OAAA1H,EAAKgJ,WAAWvH,KAAK,SAAAN,GAAU,OAACA,KAAS,IAAKV,GAFxDC,QAAQC,YALVD,QAAQC,aAiB7B8H,6BAAP,SAAwB9E,GAAxB,WACI,OAAOtK,KAAKoO,iBAAiB,CACzBpO,KAAK4O,6BAAuCtE,GAC5CtK,KAAK2O,+BAERvG,KAAK,SAAA4F,GAEF,WADcA,EAAQ,IAElB,MAAM,IAAIvM,MAAM,sBAGpB,OAAOkF,EAAK2I,yBASbF,8BAAP,SAAyBU,GAAzB,WACQ9C,EAA2B3F,QAAQC,QAAQ,IAM/C,OAJAwI,EAAUpF,QAAQ,SAAAJ,GACd0C,EAAQA,EAAM5E,KAAK,SAAA4F,GAAW,OAAArH,EAAKoJ,iBAAiBzF,GAAUlC,KAAK,SAAAN,GAAU,OAAIkG,UAASlG,UAGvFkF,GASJoC,8BAAP,SAAyB9E,EAAwBC,GAC7C,OAAOvK,KAAKoO,iBAAiB,CACzBpO,KAAK4O,6BAAuCrE,GAC5CvK,KAAK4O,mCAAuCtE,GAC5CtK,KAAK2O,+BAERvG,KAAK,SAAA4F,GAEF,WADcA,EAAQ,IAElB,MAAM,IAAIvM,MAAM,yBAcrB2N,oBAAP,SAAe7B,EAAiByC,EAAmBC,EAAsBC,EAAwBC,GAAjG,wBAAiGA,EAAuB5C,EAAU,OAAG,aAAAH,mBAAAA,IAAA0C,oBAGjI,GA/KiB,QA+KbE,EAAKA,EAAKzO,OAAS,GAAyB,CAC5C,IAAM6O,EAAU,IAAItG,YAAYkG,EAAKzO,OAAS,GAC9C6O,EAAQpI,IAAIgI,GACZI,EAAQpI,IAAI,CAlLC,OAkLmBgI,EAAKzO,OAAS,GAC9CyO,EAAOI,EAWX,IAPA,IAAMlI,EAAW,CACblI,KAAKqQ,4BAA0CJ,GAC/CjQ,KAAKqQ,4BAA0CH,GAC/ClQ,KAAKqQ,4BAA0CF,IAI1CzN,EAAI,EAAGA,EAAIsE,KAAKuE,IAAIuE,EAAUvO,OA1LhB,IA0LiDmB,IACpEwF,EAAS7G,KAAKrB,KAAKqQ,yBAAyB3N,EAAGoN,EAAUpN,KAG7D,OAAO1C,KAAKsQ,OACXlI,KAAK,WAAM,OAAAzB,EAAKyH,iBAAiBlG,KACjCE,KAAK,WAAM,OAAAzB,EAAK4J,WAAWhD,EAASyC,KACpC5H,KAAK,WAAM,OAAAzB,EAAK6J,QAAO,KACvBpI,KAAK,WAAM,OAAAzB,EAAK0H,UAAU,WAAM,OAAA1H,EAAKgJ,YAAY,IA1MlC,WAaK9C,IJ6QjB3G,EAAAA,gBAAAA,wCAQRA,kCK/RA,WAAYuK,GATJzQ,QCwDH,UDrDWA,gBAAa,GAWzBA,KAAK0Q,UAHkCvQ,IAGlBsQ,EAHSC,KAGOD,EAAaC,KAAQD,EAuFlE,OAhFWE,iBAAP,WAAA,WACI,OAAO,IAAItJ,QAAQ,SAACC,EAASuE,GACzB,IAAKlF,EAAK+J,KAAKnP,OACX,OAAOsK,EAAO,qBAGlB,IACI,IAAM+E,EAAMC,QAAQ,YACpBlK,EAAKmK,OAAS,IAAIF,EAAID,IAAIhK,EAAK+J,MAC/BpJ,IACF,MAAOyJ,GACLlF,EAAOkF,OASZJ,kBAAP,WAAA,WACI,OAAO,IAAItJ,QAAQ,SAACC,EAASC,GACrBZ,EAAKmK,QACLnK,EAAKmK,OAAO7G,QAGhB3C,OAQDqJ,iBAAP,WAAA,WACI,OAAO,IAAItJ,QAAQ,SAACC,EAASuE,GACzB,IAAKlF,EAAKmK,OAAQ,OAAOjF,EAAO,oBAEhClF,EAAKmK,OAAOpI,KAAK,SAAC5E,EAAe4D,GAC7B,GAAI5D,EACA,OAAO+H,EAAO/H,GAGlB,IAAM+D,EAAS,IAAIF,WAAWD,GAAMG,OACpCP,EAAQ,IAAIoC,SAAS7B,SAU1B8I,kBAAP,SAAajJ,GAAb,WACI,OAAO,IAAIL,QAAQ,SAACC,EAASuE,GACzB,IAAKlF,EAAKmK,OAAQ,OAAOjF,EAAO,oBAUhC,IAJA,IAAMjE,OAH4CzH,IAGvBuH,EAHYG,OAGJH,EAAKG,OAASH,EAC3Ca,EAAQ3F,MAAMC,UAAUqG,MAAMnJ,KAAK,IAAI4H,WAAWC,IAGjDW,EAAMhH,OAASoF,EAAKE,YAAY0B,EAAMlH,KAAK,GASlD,GALgB,UAAZsF,EAAKqK,IACLzI,EAAMnH,QAAQ,GAGGuF,EAAKmK,OAAOrI,MAAMF,KAClBA,EAAMhH,OAAQ,OAAOsK,EAAO,+BAEjDvE,YErFN2J,EAAwB,EAIxBC,EAAgB,iBAoClB,WAAoBJ,EAAwBK,EAAwCC,EAA+CC,gBAAvFF,kBAAwCC,kBAA+CC,MAA/GrR,YAAA8Q,EAAwB9Q,oBAAAmR,EAAwCnR,mBAAAoR,EAA+CpR,2BAAAqR,EATnHrR,gBAAa,GAgLjC,OApKYsR,6BAAR,SAAyBzJ,GACrB,IAAMD,EAAc,IAAID,WAAWE,GAAQA,OAC3C,OAAO,IAAI6B,SAAS9B,IAGhB0J,iCAAR,SAA6BC,GAKzB,IAAM3J,OAH4CzH,IAGvBoR,EAHY1J,OAGI0J,EAAa1J,OAAS0J,EACjE,OAAOC,OAAOC,KAAK7J,IAGf0J,yBAAR,SAAqB5J,EAAoBb,GAKrC,IAAMe,OAH4CzH,IAGvBuH,EAHYG,OAGJH,EAAKG,OAASH,EAC3CnG,EAASyF,KAAKuE,IAAI3D,EAAYG,WAAYlB,GAE1CiB,EAAS,IAAIH,WAAWpG,GAG9B,OAFAuG,EAAOE,IAAI,IAAIL,WAAWC,IAEnBE,GAOJwJ,iBAAP,WAAA,WACI,OAAO,IAAIjK,QAAQ,SAACC,EAASuE,GACzBlF,EAAKmK,OAAOjH,OACZlD,EAAKmK,OAAOY,iBAAiB/K,EAAKyK,cAAe,SAAAtN,GAC7C,GAAIA,EAAO,OAAO+H,EAAO/H,GACzB,IAAM6N,EAAahL,EAAKmK,OAAOa,WAAWC,OAAO,SAAAC,GAC7C,OAAOA,EAAMC,WAAWC,kBAAoBpL,EAAKwK,iBAGrD,IAAKQ,EAAWpQ,OACZ,MAAM,IAAIE,MAAM,8BAIpB,IAAIuQ,EAAoBL,EAAWM,KAAK,SAAAJ,GAAS,OAAAA,EAAMK,UAAU3Q,OAAS,IAU1E,GAPKyQ,IACDA,EAAoBL,EAAW,IAGnChL,EAAKwL,gBAAkBH,EAAkBG,iBAGpCxL,EAAK0K,sBAAuB,CAC7B,IAAMa,EAAYF,EAAkBE,UAEpCvL,EAAKyL,gBAAajS,EAClBwG,EAAK0L,iBAAclS,EAEnB,IAAuB,QAAAmS,IAAAlF,WAAAA,IAAW,CAA7B,IAAMmF,OACoB,OAAvBA,EAASC,UAAoB7L,EAAKyL,WAAcG,EAC/C5L,EAAK0L,YAAeE,EAI7B,GAAI5L,EAAKyL,YAAczL,EAAK0L,YAGxB,IACIL,EAAkBS,QACpB,MAAOC,GACL/L,EAAKyL,gBAAajS,EAClBwG,EAAK0L,iBAAclS,GAK/BmH,SASLgK,kBAAP,WAAA,WACI,OAAO,IAAIjK,QAAQ,SAACC,EAASC,GACzBZ,EAAKmK,OAAO7G,QACZ3C,OAQDgK,iBAAP,WAAA,WACI,OAAO,IAAIjK,QAAQ,SAACC,EAASuE,GACzB,QAA6B1L,IAAzBwG,EAAKwL,gBAA+B,OAAOtG,EAAO,oBAGlDlF,EAAKyL,WACLzL,EAAKyL,WAAWnE,SAAStH,EAAKE,WAAY,SAAC/C,EAAO+D,GAC9C,GAAI/D,EAAO,OAAO+H,EAAO/H,GACzBwD,EAAQX,EAAKgM,iBAAiB9K,MAMtClB,EAAKmK,OAAO8B,gBACRC,IArJG,EAYD,IA4IFlM,EAAKwL,gBACLxL,EAAKE,WACL,SAAC/C,EAAO+D,GACJ,OAAI/D,EAAc+H,EAAO/H,GACpB+D,OACLP,EAAQX,EAAKgM,iBAAiB9K,IADVgE,EAAO,uBAYpCyF,kBAAP,SAAa5J,GAAb,WACUoL,EAAW9S,KAAK+S,aAAarL,EAAM1H,KAAK6G,YACxCgB,EAAS7H,KAAKgT,qBAAqBF,GAEzC,OAAO,IAAIzL,QAAQ,SAACC,EAASuE,GACzB,QAA6B1L,IAAzBwG,EAAKwL,gBAA+B,OAAOtG,EAAO,oBAGlDlF,EAAK0L,YACL1L,EAAK0L,YAAYpE,SAASpG,EAAQ,SAAA/D,GAC9B,GAAIA,EAAO,OAAO+H,EAAO/H,GACzBwD,MAMRX,EAAKmK,OAAO8B,gBACRK,GAtLG,EAIA,IAqLHtM,EAAKwL,gBACLtK,EACA,SAAA/D,GACI,GAAIA,EAAO,OAAO+H,EAAO/H,GACzBwD,cC3Nd2J,EAAwB,EAIxBC,EAAgB,iBAqClB,WAAoBJ,EAA2BK,EAAwCC,EAA+CC,gBAAvFF,kBAAwCC,kBAA+CC,MAAlHrR,YAAA8Q,EAA2B9Q,oBAAAmR,EAAwCnR,mBAAAoR,EAA+CpR,2BAAAqR,EATtHrR,gBAAa,GA2IjC,OA/HYkT,yBAAR,SAAqBxL,EAAoBb,GAKrC,IAAMe,OAH4CzH,IAGvBuH,EAHYG,OAGJH,EAAKG,OAASH,EAC3CnG,EAASyF,KAAKuE,IAAI3D,EAAYG,WAAYlB,GAE1CiB,EAAS,IAAIH,WAAWpG,GAG9B,OAFAuG,EAAOE,IAAI,IAAIL,WAAWC,IAEnBE,GAOJoL,iBAAP,WAAA,WACI,OAAOlT,KAAK8Q,OAAOjH,OAClBzB,KAAK,WAAM,OAAAzB,EAAKmK,OAAOqC,oBAAoBxM,EAAKyK,iBAChDhJ,KAAK,WACF,IAAMuJ,EAAahL,EAAKmK,OAAOM,cAAeO,WAAWC,OAAO,SAAAC,GAC5D,OAAOA,EAAMuB,WAAW,GAAGjC,iBAAmBxK,EAAKwK,iBAGvD,IAAKQ,EAAWpQ,OACZ,MAAM,IAAIE,MAAM,8BAIpB,IAAIuQ,EAAoBL,EAAWM,KAAK,SAAAJ,GAAS,OAAAA,EAAMuB,WAAW,GAAGlB,UAAU3Q,OAAS,IAUxF,GAPKyQ,IACDA,EAAoBL,EAAW,IAGnChL,EAAKwL,gBAAkBH,EAAkBG,iBAGpCxL,EAAK0K,sBAAuB,CAC7B,IAAMa,EAAYF,EAAkBoB,WAAW,GAAGlB,UAElDvL,EAAKyL,gBAAajS,EAClBwG,EAAK0L,iBAAclS,EAEnB,IAAuB,QAAAmS,IAAAlF,WAAAA,IAAW,CAA7B,IAAMmF,OACoB,OAAvBA,EAASC,UAAoB7L,EAAKyL,WAAaG,EAC9C5L,EAAK0L,YAAcE,GAIhC,OAAO5L,EAAKmK,OAAOuC,eAAe1M,EAAKwL,oBAQxCe,kBAAP,WACI,OAAOlT,KAAK8Q,OAAO7G,SAOhBiJ,iBAAP,WACI,YAA6B/S,IAAzBH,KAAKmS,gBAAsC9K,QAAQwE,OAAO,oBAG1D7L,KAAKoS,WACEpS,KAAK8Q,OAAOwC,WACftT,KAAKoS,WAAWmB,eAChBvT,KAAK6G,YAERuB,KAAK,SAAAN,GAAU,OAAAA,EAAOJ,OAIpB1H,KAAK8Q,OAAO0C,kBACf,CACIC,YAAa,QACbC,UAAW,YACX7K,QAzHG,EA0HH0B,MA9GE,IA+GFjF,MAAOtF,KAAKmS,iBAEhBnS,KAAK6G,YAERuB,KAAK,SAAAN,GAAU,OAAAA,EAAOJ,QAQpBwL,kBAAP,SAAaxL,GACT,QAA6BvH,IAAzBH,KAAKmS,gBAA+B,OAAO9K,QAAQwE,OAAO,oBAE9D,IAAMhE,EAAS7H,KAAK+S,aAAarL,EAAM1H,KAAK6G,YAG5C,OAAI7G,KAAKqS,YACErS,KAAK8Q,OAAO6C,YACf3T,KAAKqS,YAAYkB,eACjB1L,GAEHO,KAAK,cAIHpI,KAAK8Q,OAAO8C,mBACf,CACIH,YAAa,QACbC,UAAW,YACX7K,QAtJG,EAuJH0B,MAnJG,IAoJHjF,MAAOtF,KAAKmS,iBAEhBtK,GAEHO,KAAK"}